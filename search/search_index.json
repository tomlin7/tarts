{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tarts LSP Client","text":"<p>Tarts is a client library for managing language server requests &amp; responses. Tarts is the featured lsp integration used in Biscuit code editor.</p>"},{"location":"#testing","title":"Testing","text":"<p>Tests of Tarts use pytest. To run tests, first install the langservers needed, check workflow file for further info.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Tarts is an up-to-date fork of sansio_lsp_client by Purple Myst.</p>"},{"location":"api/client/","title":"API Reference","text":""},{"location":"api/client/#clientstate","title":"ClientState","text":"<p>               Bases: <code>Enum</code></p> <p>The state of a client.</p> Source code in <code>tarts\\client.py</code> <pre><code>class ClientState(enum.Enum):\n    \"\"\"The state of a client.\"\"\"\n\n    NOT_INITIALIZED = enum.auto()\n    WAITING_FOR_INITIALIZED = enum.auto()\n    NORMAL = enum.auto()\n    WAITING_FOR_SHUTDOWN = enum.auto()\n    SHUTDOWN = enum.auto()\n    EXITED = enum.auto()\n</code></pre>"},{"location":"api/client/#client","title":"Client","text":"<p>A Sans-IO client for the communicating with a Language Servers</p> <p>This client does not handle any IO itself, but instead provides methods for generating requests and parsing responses. The user is expected to call <code>send</code> to get the bytes to send to the server, and <code>recv</code> to feed the bytes received from the server back into the client.</p> <p>The client will keep track of the state of the connection, and will raise an error if the user tries to send a request that is not allowed in the current state.</p> <p>Parameters:</p> Name Type Description Default <code>process_id</code> <code>Optional[int]</code> <p>The process ID of the client. This is used for logging purposes.</p> <code>None</code> <code>root_uri</code> <code>Optional[str]</code> <p>The root URI of the workspace. This is used for logging purposes.</p> <code>None</code> <code>workspace_folders</code> <code>Optional[List[WorkspaceFolder]]</code> <p>A list of workspace folders. This is used for logging purposes.</p> <code>None</code> <code>trace</code> <code>str</code> <p>The trace level to use. This is used for logging purposes.</p> <code>'off'</code> Source code in <code>tarts\\client.py</code> <pre><code>class Client:\n    \"\"\"A Sans-IO client for the communicating with a Language Servers\n\n    This client does not handle any IO itself, but instead provides methods for\n    generating requests and parsing responses. The user is expected to call\n    `send` to get the bytes to send to the server, and `recv` to feed the bytes\n    received from the server back into the client.\n\n    The client will keep track of the state of the connection, and will raise\n    an error if the user tries to send a request that is not allowed in the\n    current state.\n\n    Args:\n        process_id: The process ID of the client. This is used for logging\n            purposes.\n        root_uri: The root URI of the workspace. This is used for logging\n            purposes.\n        workspace_folders: A list of workspace folders. This is used for logging\n            purposes.\n        trace: The trace level to use. This is used for logging purposes.\n    \"\"\"\n\n    # TODO: Save the encoding given here.\n    def __init__(\n        self,\n        process_id: t.Optional[int] = None,\n        root_uri: t.Optional[str] = None,\n        workspace_folders: t.Optional[t.List[WorkspaceFolder]] = None,\n        trace: str = \"off\",\n    ) -&gt; None:\n        self._state = ClientState.NOT_INITIALIZED\n\n        # Used to save data as it comes in (from `recieve_bytes`) until we have\n        # a full request.\n        self._recv_buf = bytearray()\n\n        # Things that we still need to send.\n        self._send_buf = bytearray()\n\n        # Keeps track of which IDs match to which unanswered requests.\n        self._unanswered_requests: t.Dict[Id, Request] = {}\n\n        # Just a simple counter to make sure we have unique IDs. We could make\n        # sure that this fits into a JSONRPC Number, seeing as Python supports\n        # bignums, but I think that's an unlikely enough case that checking for\n        # it would just litter the code unnecessarily.\n        self._id_counter = 0\n\n        # We'll just immediately send off an \"initialize\" request.\n        self._send_request(\n            method=\"initialize\",\n            params={\n                \"processId\": process_id,\n                \"rootUri\": root_uri,\n                \"workspaceFolders\": (\n                    None\n                    if workspace_folders is None\n                    else [f.dict() for f in workspace_folders]\n                ),\n                \"trace\": trace,\n                \"capabilities\": CAPABILITIES,\n            },\n        )\n        self._state = ClientState.WAITING_FOR_INITIALIZED\n\n    @property\n    def state(self) -&gt; ClientState:\n        \"\"\"The current state of the client.\"\"\"\n        return self._state\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        \"\"\"Whether the client has been initialized.\"\"\"\n        return (\n            self._state != ClientState.NOT_INITIALIZED\n            and self._state != ClientState.WAITING_FOR_INITIALIZED\n        )\n\n    def _send_request(self, method: str, params: t.Optional[JSONDict] = None) -&gt; int:\n        \"\"\"Send a request to the server.\n\n        This method can be used to send requests that are not implemented in the\n        client. It will also automatically generate an ID for the request.\n\n        Args:\n            method: The method of the request.\n            params: The parameters of the request.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        id = self._id_counter\n        self._id_counter += 1\n\n        self._send_buf += _make_request(method=method, params=params, id=id)\n        self._unanswered_requests[id] = Request(id=id, method=method, params=params)\n        return id\n\n    def _send_notification(\n        self, method: str, params: t.Optional[JSONDict] = None\n    ) -&gt; None:\n        \"\"\"Send a notification to the server.\n\n        This method can be used to send notifications that are not implemented in\n        the client.\n\n        Args:\n            method: The method of the notification.\n            params: The parameters of the notification.\n        \"\"\"\n        self._send_buf += _make_request(method=method, params=params)\n\n    def _send_response(\n        self,\n        id: int | str,\n        result: t.Optional[t.Union[JSONDict, JSONList]] = None,\n        error: t.Optional[JSONDict] = None,\n    ) -&gt; None:\n        \"\"\"Send a response to the server.\n\n        This method can be used to send responses that are not implemented in the\n        client.\n\n        Args:\n            id: The ID of the request that this response is for.\n            result: The result of the request.\n            error: The error of the request\n        \"\"\"\n\n        self._send_buf += _make_response(id=id, result=result, error=error)\n\n    # response from server\n    def _handle_response(self, response: Response) -&gt; Event:\n        assert response.id is not None\n        request = self._unanswered_requests.pop(response.id)\n\n        if response.error is not None:\n            err = ResponseError.parse_obj(response.error)\n            err.message_id = response.id\n            return err\n\n        event: Event\n\n        match request.method:\n            case \"initialize\":\n                assert self._state == ClientState.WAITING_FOR_INITIALIZED\n                self._send_notification(\n                    \"initialized\", params={}\n                )  # params=None doesn't work with gopls\n                event = Initialized.parse_obj(response.result)\n                self._state = ClientState.NORMAL\n\n            case \"shutdown\":\n                assert self._state == ClientState.WAITING_FOR_SHUTDOWN\n                event = Shutdown()\n                self._state = ClientState.SHUTDOWN\n\n            case \"textDocument/completion\":\n                completion_list = None\n\n                try:\n                    completion_list = CompletionList.parse_obj(response.result)\n                except ValidationError:\n                    try:\n                        completion_list = CompletionList(\n                            isIncomplete=False,\n                            items=parse_obj_as(t.List[CompletionItem], response.result),\n                        )\n                    except ValidationError:\n                        assert response.result is None\n\n                event = Completion(\n                    message_id=response.id, completion_list=completion_list\n                )\n\n            case \"textDocument/willSaveWaitUntil\":\n                event = WillSaveWaitUntilEdits(\n                    edits=parse_obj_as(t.List[TextEdit], response.result)\n                )\n\n            case \"textDocument/hover\":\n                if response.result is not None:\n                    event = Hover.parse_obj(response.result)\n                else:\n                    event = Hover(contents=[])  # null response\n                event.message_id = response.id\n\n            case \"textDocument/foldingRange\":\n                event = parse_obj_as(MFoldingRanges, response)\n                event.message_id = response.id\n\n            case \"textDocument/signatureHelp\":\n                if response.result is not None:\n                    event = SignatureHelp.parse_obj(response.result)\n                else:\n                    event = SignatureHelp(signatures=[])  # null response\n                event.message_id = response.id\n\n            case \"textDocument/documentSymbol\":\n                event = parse_obj_as(MDocumentSymbols, response)\n                event.message_id = response.id\n\n            case \"textDocument/inlayHint\":\n                event = parse_obj_as(MInlayHints, response)\n                event.message_id = response.id\n\n            case \"textDocument/rename\":\n                event = parse_obj_as(WorkspaceEdit, response.result)\n                event.message_id = response.id\n\n            # GOTOs\n            case \"textDocument/definition\":\n                event = parse_obj_as(Definition, response)\n                event.message_id = response.id\n\n            case \"textDocument/references\":\n                event = parse_obj_as(References, response)\n            case \"textDocument/implementation\":\n                event = parse_obj_as(Implementation, response)\n            case \"textDocument/declaration\":\n                event = parse_obj_as(Declaration, response)\n            case \"textDocument/typeDefinition\":\n                event = parse_obj_as(TypeDefinition, response)\n\n            case \"textDocument/prepareCallHierarchy\":\n                event = parse_obj_as(MCallHierarchItems, response)\n\n            case \"textDocument/formatting\" | \"textDocument/rangeFormatting\":\n                event = parse_obj_as(DocumentFormatting, response)\n                event.message_id = response.id\n\n            # WORKSPACE\n            case \"workspace/symbol\":\n                event = parse_obj_as(MWorkspaceSymbols, response)\n\n            case _:\n                raise NotImplementedError((response, request))\n\n        return event\n\n    # request from server\n    def _handle_request(self, request: Request) -&gt; Event:\n        def parse_request(event_cls: t.Type[Event]) -&gt; Event:\n            if issubclass(event_cls, ServerRequest):\n                event = parse_obj_as(event_cls, request.params)\n                assert request.id is not None\n                event._id = request.id\n                event._client = self\n                return event\n            elif issubclass(event_cls, ServerNotification):\n                return parse_obj_as(event_cls, request.params)\n            else:\n                raise TypeError(\n                    \"`event_cls` must be a subclass of ServerRequest\"\n                    \" or ServerNotification\"\n                )\n\n        if request.method == \"workspace/workspaceFolders\":\n            return parse_request(WorkspaceFolders)\n        elif request.method == \"workspace/configuration\":\n            return parse_request(ConfigurationRequest)\n        elif request.method == \"window/showMessage\":\n            return parse_request(ShowMessage)\n        elif request.method == \"window/showMessageRequest\":\n            return parse_request(ShowMessageRequest)\n        elif request.method == \"window/logMessage\":\n            return parse_request(LogMessage)\n        elif request.method == \"textDocument/publishDiagnostics\":\n            return parse_request(PublishDiagnostics)\n        elif request.method == \"window/workDoneProgress/create\":\n            return parse_request(WorkDoneProgressCreate)\n        elif request.method == \"client/registerCapability\":\n            return parse_request(RegisterCapabilityRequest)\n\n        elif request.method == \"$/progress\":\n            assert request.params is not None\n            kind = MWorkDoneProgressKind(request.params[\"value\"][\"kind\"])\n            if kind == MWorkDoneProgressKind.BEGIN:\n                return parse_request(WorkDoneProgressBegin)\n            elif kind == MWorkDoneProgressKind.REPORT:\n                return parse_request(WorkDoneProgressReport)\n            elif kind == MWorkDoneProgressKind.END:\n                return parse_request(WorkDoneProgressEnd)\n            else:\n                raise RuntimeError(\"this shouldn't happen\")\n\n        else:\n            raise NotImplementedError(request)\n\n    def recv(self, data: bytes) -&gt; t.Iterator[Event]:\n        \"\"\"Feed data received from the server back into the client.\n\n        This method will parse the data received from the server, and yield any\n        events that are generated by the data. If the data is not enough to\n        generate a full event, the data will be saved until enough data is\n        received.\n\n        Args:\n            data: The data received from the server.\n\n        Yields:\n            The events generated by the data.\"\"\"\n        self._recv_buf += data\n        # Make sure to use lots of iterators, so that if one message fails to\n        # parse, the messages before it are yielded successfully before the\n        # error, and the messages after it are left in _recv_buf.\n        for message in _parse_messages(self._recv_buf):\n            if isinstance(message, Response):\n                yield self._handle_response(message)\n            else:\n                yield self._handle_request(message)\n\n    def send(self) -&gt; bytes:\n        \"\"\"Get the bytes to send to the server.\n\n        This method will return the bytes that need to be sent to the server.\n        This is the main way to interact with the client.\n\n        Returns:\n            The bytes to send to the server.\n        \"\"\"\n\n        send_buf = self._send_buf[:]\n        self._send_buf.clear()\n        return send_buf\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Send a shutdown request to the server.\n\n        This method will send a shutdown request to the server. After this\n        request is sent, the client will be in the `WAITING_FOR_SHUTDOWN` state.\"\"\"\n\n        assert self._state == ClientState.NORMAL\n        self._send_request(method=\"shutdown\")\n        self._state = ClientState.WAITING_FOR_SHUTDOWN\n\n    def exit(self) -&gt; None:\n        \"\"\"Send an exit notification to the server.\n\n        This method will send an exit notification to the server. After this\n        notification is sent, the client will be in the `EXITED` state.\"\"\"\n        assert self._state == ClientState.SHUTDOWN\n        # TODO: figure out why params={} is needed\n        self._send_notification(method=\"exit\", params={})\n        self._state = ClientState.EXITED\n\n    def cancel_last_request(self) -&gt; None:\n        \"\"\"Cancel the last request sent to the server.\n\n        This method will cancel the last request sent to the server. This is\n        useful if the request is taking too long to process.\"\"\"\n\n        self._send_notification(\n            method=\"$/cancelRequest\", params={\"id\": self._id_counter - 1}\n        )\n\n    def did_open(self, text_document: TextDocumentItem) -&gt; None:\n        \"\"\"Send a didOpen notification to the server.\n\n        This method will send a didOpen notification to the server. This\n        notification is used to inform the server that a document has been\n        opened.\n\n        Args:\n            text_document: The text document that has been opened.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        self._send_notification(\n            method=\"textDocument/didOpen\", params={\"textDocument\": text_document.dict()}\n        )\n\n    def did_change(\n        self,\n        text_document: VersionedTextDocumentIdentifier,\n        content_changes: t.List[TextDocumentContentChangeEvent],\n    ) -&gt; None:\n        \"\"\"Send a didChange notification to the server.\n\n        This method will send a didChange notification to the server. This\n        notification is used to inform the server that a document has been\n        changed.\n\n        Args:\n            text_document: The text document that has been changed.\n            content_changes: The changes that have been made to the document.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        self._send_notification(\n            method=\"textDocument/didChange\",\n            params={\n                \"textDocument\": text_document.dict(),\n                \"contentChanges\": [evt.dict() for evt in content_changes],\n            },\n        )\n\n    def will_save(\n        self, text_document: TextDocumentIdentifier, reason: TextDocumentSaveReason\n    ) -&gt; None:\n        \"\"\"Send a willSave notification to the server.\n\n        This method will send a willSave notification to the server. This\n        notification is used to inform the server that a document will be saved.\n\n        Args:\n            text_document: The text document that will be saved.\n            reason: The reason the document will be saved.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        self._send_notification(\n            method=\"textDocument/willSave\",\n            params={\"textDocument\": text_document.dict(), \"reason\": reason.value},\n        )\n\n    def will_save_wait_until(\n        self, text_document: TextDocumentIdentifier, reason: TextDocumentSaveReason\n    ) -&gt; None:\n        \"\"\"Send a willSaveWaitUntil request to the server.\n\n        This method will send a willSaveWaitUntil request to the server. This\n\n        Args:\n            text_document: The text document that will be saved.\n            reason: The reason the document will be saved.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        self._send_request(\n            method=\"textDocument/willSaveWaitUntil\",\n            params={\"textDocument\": text_document.dict(), \"reason\": reason.value},\n        )\n\n    def did_save(\n        self, text_document: TextDocumentIdentifier, text: t.Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Send a didSave notification to the server.\n\n        This method will send a didSave notification to the server. This\n        notification is used to inform the server that a document has been saved.\n\n        Args:\n            text_document: The text document that has been saved.\n            text: The text of the document that has been saved. This is optional,\n                and can be used to send the text of the document if it has changed\n                since the last didChange notification.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        params: t.Dict[str, t.Any] = {\"textDocument\": text_document.dict()}\n        if text is not None:\n            params[\"text\"] = text\n        self._send_notification(method=\"textDocument/didSave\", params=params)\n\n    def did_close(self, text_document: TextDocumentIdentifier) -&gt; None:\n        \"\"\"Send a didClose notification to the server.\n\n        This method will send a didClose notification to the server. This\n        notification is used to inform the server that a document has been closed.\n\n        Args:\n            text_document: The text document that has been closed.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        self._send_notification(\n            method=\"textDocument/didClose\",\n            params={\"textDocument\": text_document.dict()},\n        )\n\n    def did_change_configuration(self, settings: list[t.Any]) -&gt; None:\n        \"\"\"Send a didChangeConfiguration notification to the server.\n\n        This method will send a didChangeConfiguration notification to the server.\n        This notification is used to inform the server that the configuration has\n        changed.\n\n        Args:\n            settings: The new settings.\n        \"\"\"\n        assert self._state == ClientState.NORMAL\n        self._send_notification(\n            method=\"workspace/didChangeConfiguration\", params=settings\n        )\n\n    def did_change_workspace_folders(\n        self, added: t.List[WorkspaceFolder], removed: t.List[WorkspaceFolder]\n    ) -&gt; None:\n        \"\"\"Send a didChangeWorkspaceFolders notification to the server.\n\n        This method will send a didChangeWorkspaceFolders notification to the\n        server. This notification is used to inform the server that workspace\n        folders have been added or removed.\n\n        Args:\n            added: The workspace folders that have been added.\n            removed: The workspace folders that have been removed.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        params = {\n            \"added\": [f.dict() for f in added],\n            \"removed\": [f.dict() for f in removed],\n        }\n        self._send_notification(\n            method=\"workspace/didChangeWorkspaceFolders\", params=params\n        )\n\n    def completion(\n        self,\n        text_document_position: TextDocumentPosition,\n        context: t.Optional[CompletionContext] = None,\n    ) -&gt; int:\n        \"\"\"Send a completion request to the server.\n\n        This method will send a completion request to the server. This request is\n        used to request completion items at a specific position in a document.\n\n        Args:\n            text_document_position: The position in the document to request\n                completions for.\n            context: The context in which the completion is requested.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        params = {}\n        params.update(text_document_position.dict())\n        if context is not None:\n            params.update(context.dict())\n        return self._send_request(method=\"textDocument/completion\", params=params)\n\n    def rename(\n        self,\n        text_document_position: TextDocumentPosition,\n        new_name: str,\n    ) -&gt; int:\n        \"\"\"Send a rename request to the server.\n\n        This method will send a rename request to the server. This request is\n        used to request that the server rename a symbol in a document.\n\n        Args:\n            text_document_position: The position in the document to rename.\n            new_name: The new name of the symbol.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        params = {}\n        params.update(text_document_position.dict())\n        params[\"newName\"] = new_name\n        return self._send_request(method=\"textDocument/rename\", params=params)\n\n    def hover(self, text_document_position: TextDocumentPosition) -&gt; int:\n        \"\"\"Send a hover request to the server.\n\n        This method will send a hover request to the server. This request is\n        used to request hover information at a specific position in a document.\n\n        Args:\n            text_document_position: The position in the document to request\n                hover information for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/hover\", params=text_document_position.dict()\n        )\n\n    def folding_range(self, text_document: TextDocumentIdentifier) -&gt; int:\n        \"\"\"Send a foldingRange request to the server.\n\n        This method will send a foldingRange request to the server. This request is\n        used to request folding ranges in a document.\n\n        Args:\n            text_document: The document to request folding ranges for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/foldingRange\",\n            params={\"textDocument\": text_document.dict()},\n        )\n\n    def signatureHelp(self, text_document_position: TextDocumentPosition) -&gt; int:\n        \"\"\"Send a signatureHelp request to the server.\n\n        This method will send a signatureHelp request to the server. This request is\n        used to request signature help at a specific position in a document.\n\n        Args:\n            text_document_position: The position in the document to request\n                signature help for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/signatureHelp\", params=text_document_position.dict()\n        )\n\n    def definition(self, text_document_position: TextDocumentPosition) -&gt; int:\n        \"\"\"Send a definition request to the server.\n\n        This method will send a definition request to the server. This request is\n        used to request the definition of a symbol at a specific position in a\n        document.\n\n        Args:\n            text_document_position: The position in the document to request\n                the definition for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/definition\", params=text_document_position.dict()\n        )\n\n    def declaration(self, text_document_position: TextDocumentPosition) -&gt; int:\n        \"\"\"Send a declaration request to the server.\n\n        This method will send a declaration request to the server. This request is\n        used to request the declaration of a symbol at a specific position in a\n        document.\n\n        Args:\n            text_document_position: The position in the document to request\n                the declaration for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/declaration\", params=text_document_position.dict()\n        )\n\n    def inlay_hint(self, text_document: TextDocumentIdentifier, range: Range) -&gt; int:\n        \"\"\"Send a inlayHint request to the server.\n\n        This method will send a inlayHint request to the server. This request is\n        used to request inlay hints in a document.\n\n        Args:\n            text_document: The document to request inlay hints for.\n            range: The range to request inlay hints for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/inlayHint\",\n            params={\"textDocument\": text_document.dict(), \"range\": range.dict()},\n        )\n\n    def typeDefinition(self, text_document_position: TextDocumentPosition) -&gt; int:\n        \"\"\"Send a typeDefinition request to the server.\n\n        This method will send a typeDefinition request to the server. This request is\n        used to request the type definition of a symbol at a specific position in a\n        document.\n\n        Args:\n            text_document_position: The position in the document to request\n                the type definition for.\n\n        Returns:\n            The ID of the request.\"\"\"\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/typeDefinition\", params=text_document_position.dict()\n        )\n\n    def references(self, text_document_position: TextDocumentPosition) -&gt; int:\n        \"\"\"Send a references request to the server.\n\n        This method will send a references request to the server. This request is\n        used to request references to a symbol at a specific position in a\n        document.\n\n        Args:\n            text_document_position: The position in the document to request\n                references for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        params = {\n            \"context\": {\"includeDeclaration\": True},\n            **text_document_position.dict(),\n        }\n        return self._send_request(method=\"textDocument/references\", params=params)\n\n    # TODO incomplete\n    def prepareCallHierarchy(self, text_document_position: TextDocumentPosition) -&gt; int:\n        \"\"\"Send a prepareCallHierarchy request to the server.\n\n        This method will send a prepareCallHierarchy request to the server. This\n        request is used to request call hierarchy information at a specific position\n        in a document.\n\n        Args:\n            text_document_position: The position in the document to request\n                call hierarchy information for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/prepareCallHierarchy\",\n            params=text_document_position.dict(),\n        )\n\n    def implementation(self, text_document_position: TextDocumentPosition) -&gt; int:\n        \"\"\"Send a implementation request to the server.\n\n        This method will send a implementation request to the server. This request is\n        used to request the implementation of a symbol at a specific position in a\n        document.\n\n        Args:\n            text_document_position: The position in the document to request\n                the implementation for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/implementation\", params=text_document_position.dict()\n        )\n\n    def workspace_symbol(self, query: str = \"\") -&gt; int:\n        \"\"\"Send a workspace/symbol request to the server.\n\n        This method will send a workspace/symbol request to the server. This request\n        is used to request symbols in the workspace.\n\n        Args:\n            query: The query to filter symbols by.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(method=\"workspace/symbol\", params={\"query\": query})\n\n    def documentSymbol(self, text_document: TextDocumentIdentifier) -&gt; int:\n        \"\"\"Send a documentSymbol request to the server.\n\n        This method will send a documentSymbol request to the server. This request\n        is used to request symbols in a document.\n\n        Args:\n            text_document: The document to request symbols for.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        return self._send_request(\n            method=\"textDocument/documentSymbol\",\n            params={\"textDocument\": text_document.dict()},\n        )\n\n    def formatting(\n        self, text_document: TextDocumentIdentifier, options: FormattingOptions\n    ) -&gt; int:\n        \"\"\"Send a formatting request to the server.\n\n        This method will send a formatting request to the server. This request is\n        used to request formatting for a document.\n\n        Args:\n            text_document: The document to request formatting for.\n            options: The options to use for formatting.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        params = {\"textDocument\": text_document.dict(), \"options\": options.dict()}\n        return self._send_request(method=\"textDocument/formatting\", params=params)\n\n    def rangeFormatting(\n        self,\n        text_document: TextDocumentIdentifier,\n        range: Range,\n        options: FormattingOptions,\n    ) -&gt; int:\n        \"\"\"Send a rangeFormatting request to the server.\n\n        This method will send a rangeFormatting request to the server. This request\n        is used to request formatting for a range in a document.\n\n        Args:\n            text_document: The document to request formatting for.\n            range: The range to request formatting for.\n            options: The options to use for formatting.\n\n        Returns:\n            The ID of the request.\n        \"\"\"\n\n        assert self._state == ClientState.NORMAL\n        params = {\n            \"textDocument\": text_document.dict(),\n            \"range\": range.dict(),\n            \"options\": options.dict(),\n        }\n        return self._send_request(method=\"textDocument/rangeFormatting\", params=params)\n</code></pre>"},{"location":"api/client/#tarts.client.Client.is_initialized","title":"<code>is_initialized: bool</code>  <code>property</code>","text":"<p>Whether the client has been initialized.</p>"},{"location":"api/client/#tarts.client.Client.state","title":"<code>state: ClientState</code>  <code>property</code>","text":"<p>The current state of the client.</p>"},{"location":"api/client/#tarts.client.Client.cancel_last_request","title":"<code>cancel_last_request()</code>","text":"<p>Cancel the last request sent to the server.</p> <p>This method will cancel the last request sent to the server. This is useful if the request is taking too long to process.</p> Source code in <code>tarts\\client.py</code> <pre><code>def cancel_last_request(self) -&gt; None:\n    \"\"\"Cancel the last request sent to the server.\n\n    This method will cancel the last request sent to the server. This is\n    useful if the request is taking too long to process.\"\"\"\n\n    self._send_notification(\n        method=\"$/cancelRequest\", params={\"id\": self._id_counter - 1}\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.completion","title":"<code>completion(text_document_position, context=None)</code>","text":"<p>Send a completion request to the server.</p> <p>This method will send a completion request to the server. This request is used to request completion items at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request completions for.</p> required <code>context</code> <code>Optional[CompletionContext]</code> <p>The context in which the completion is requested.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def completion(\n    self,\n    text_document_position: TextDocumentPosition,\n    context: t.Optional[CompletionContext] = None,\n) -&gt; int:\n    \"\"\"Send a completion request to the server.\n\n    This method will send a completion request to the server. This request is\n    used to request completion items at a specific position in a document.\n\n    Args:\n        text_document_position: The position in the document to request\n            completions for.\n        context: The context in which the completion is requested.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    params = {}\n    params.update(text_document_position.dict())\n    if context is not None:\n        params.update(context.dict())\n    return self._send_request(method=\"textDocument/completion\", params=params)\n</code></pre>"},{"location":"api/client/#tarts.client.Client.declaration","title":"<code>declaration(text_document_position)</code>","text":"<p>Send a declaration request to the server.</p> <p>This method will send a declaration request to the server. This request is used to request the declaration of a symbol at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request the declaration for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def declaration(self, text_document_position: TextDocumentPosition) -&gt; int:\n    \"\"\"Send a declaration request to the server.\n\n    This method will send a declaration request to the server. This request is\n    used to request the declaration of a symbol at a specific position in a\n    document.\n\n    Args:\n        text_document_position: The position in the document to request\n            the declaration for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/declaration\", params=text_document_position.dict()\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.definition","title":"<code>definition(text_document_position)</code>","text":"<p>Send a definition request to the server.</p> <p>This method will send a definition request to the server. This request is used to request the definition of a symbol at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request the definition for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def definition(self, text_document_position: TextDocumentPosition) -&gt; int:\n    \"\"\"Send a definition request to the server.\n\n    This method will send a definition request to the server. This request is\n    used to request the definition of a symbol at a specific position in a\n    document.\n\n    Args:\n        text_document_position: The position in the document to request\n            the definition for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/definition\", params=text_document_position.dict()\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.did_change","title":"<code>did_change(text_document, content_changes)</code>","text":"<p>Send a didChange notification to the server.</p> <p>This method will send a didChange notification to the server. This notification is used to inform the server that a document has been changed.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>VersionedTextDocumentIdentifier</code> <p>The text document that has been changed.</p> required <code>content_changes</code> <code>List[TextDocumentContentChangeEvent]</code> <p>The changes that have been made to the document.</p> required Source code in <code>tarts\\client.py</code> <pre><code>def did_change(\n    self,\n    text_document: VersionedTextDocumentIdentifier,\n    content_changes: t.List[TextDocumentContentChangeEvent],\n) -&gt; None:\n    \"\"\"Send a didChange notification to the server.\n\n    This method will send a didChange notification to the server. This\n    notification is used to inform the server that a document has been\n    changed.\n\n    Args:\n        text_document: The text document that has been changed.\n        content_changes: The changes that have been made to the document.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    self._send_notification(\n        method=\"textDocument/didChange\",\n        params={\n            \"textDocument\": text_document.dict(),\n            \"contentChanges\": [evt.dict() for evt in content_changes],\n        },\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.did_change_configuration","title":"<code>did_change_configuration(settings)</code>","text":"<p>Send a didChangeConfiguration notification to the server.</p> <p>This method will send a didChangeConfiguration notification to the server. This notification is used to inform the server that the configuration has changed.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>list[Any]</code> <p>The new settings.</p> required Source code in <code>tarts\\client.py</code> <pre><code>def did_change_configuration(self, settings: list[t.Any]) -&gt; None:\n    \"\"\"Send a didChangeConfiguration notification to the server.\n\n    This method will send a didChangeConfiguration notification to the server.\n    This notification is used to inform the server that the configuration has\n    changed.\n\n    Args:\n        settings: The new settings.\n    \"\"\"\n    assert self._state == ClientState.NORMAL\n    self._send_notification(\n        method=\"workspace/didChangeConfiguration\", params=settings\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.did_change_workspace_folders","title":"<code>did_change_workspace_folders(added, removed)</code>","text":"<p>Send a didChangeWorkspaceFolders notification to the server.</p> <p>This method will send a didChangeWorkspaceFolders notification to the server. This notification is used to inform the server that workspace folders have been added or removed.</p> <p>Parameters:</p> Name Type Description Default <code>added</code> <code>List[WorkspaceFolder]</code> <p>The workspace folders that have been added.</p> required <code>removed</code> <code>List[WorkspaceFolder]</code> <p>The workspace folders that have been removed.</p> required Source code in <code>tarts\\client.py</code> <pre><code>def did_change_workspace_folders(\n    self, added: t.List[WorkspaceFolder], removed: t.List[WorkspaceFolder]\n) -&gt; None:\n    \"\"\"Send a didChangeWorkspaceFolders notification to the server.\n\n    This method will send a didChangeWorkspaceFolders notification to the\n    server. This notification is used to inform the server that workspace\n    folders have been added or removed.\n\n    Args:\n        added: The workspace folders that have been added.\n        removed: The workspace folders that have been removed.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    params = {\n        \"added\": [f.dict() for f in added],\n        \"removed\": [f.dict() for f in removed],\n    }\n    self._send_notification(\n        method=\"workspace/didChangeWorkspaceFolders\", params=params\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.did_close","title":"<code>did_close(text_document)</code>","text":"<p>Send a didClose notification to the server.</p> <p>This method will send a didClose notification to the server. This notification is used to inform the server that a document has been closed.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The text document that has been closed.</p> required Source code in <code>tarts\\client.py</code> <pre><code>def did_close(self, text_document: TextDocumentIdentifier) -&gt; None:\n    \"\"\"Send a didClose notification to the server.\n\n    This method will send a didClose notification to the server. This\n    notification is used to inform the server that a document has been closed.\n\n    Args:\n        text_document: The text document that has been closed.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    self._send_notification(\n        method=\"textDocument/didClose\",\n        params={\"textDocument\": text_document.dict()},\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.did_open","title":"<code>did_open(text_document)</code>","text":"<p>Send a didOpen notification to the server.</p> <p>This method will send a didOpen notification to the server. This notification is used to inform the server that a document has been opened.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentItem</code> <p>The text document that has been opened.</p> required Source code in <code>tarts\\client.py</code> <pre><code>def did_open(self, text_document: TextDocumentItem) -&gt; None:\n    \"\"\"Send a didOpen notification to the server.\n\n    This method will send a didOpen notification to the server. This\n    notification is used to inform the server that a document has been\n    opened.\n\n    Args:\n        text_document: The text document that has been opened.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    self._send_notification(\n        method=\"textDocument/didOpen\", params={\"textDocument\": text_document.dict()}\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.did_save","title":"<code>did_save(text_document, text=None)</code>","text":"<p>Send a didSave notification to the server.</p> <p>This method will send a didSave notification to the server. This notification is used to inform the server that a document has been saved.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The text document that has been saved.</p> required <code>text</code> <code>Optional[str]</code> <p>The text of the document that has been saved. This is optional, and can be used to send the text of the document if it has changed since the last didChange notification.</p> <code>None</code> Source code in <code>tarts\\client.py</code> <pre><code>def did_save(\n    self, text_document: TextDocumentIdentifier, text: t.Optional[str] = None\n) -&gt; None:\n    \"\"\"Send a didSave notification to the server.\n\n    This method will send a didSave notification to the server. This\n    notification is used to inform the server that a document has been saved.\n\n    Args:\n        text_document: The text document that has been saved.\n        text: The text of the document that has been saved. This is optional,\n            and can be used to send the text of the document if it has changed\n            since the last didChange notification.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    params: t.Dict[str, t.Any] = {\"textDocument\": text_document.dict()}\n    if text is not None:\n        params[\"text\"] = text\n    self._send_notification(method=\"textDocument/didSave\", params=params)\n</code></pre>"},{"location":"api/client/#tarts.client.Client.documentSymbol","title":"<code>documentSymbol(text_document)</code>","text":"<p>Send a documentSymbol request to the server.</p> <p>This method will send a documentSymbol request to the server. This request is used to request symbols in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The document to request symbols for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def documentSymbol(self, text_document: TextDocumentIdentifier) -&gt; int:\n    \"\"\"Send a documentSymbol request to the server.\n\n    This method will send a documentSymbol request to the server. This request\n    is used to request symbols in a document.\n\n    Args:\n        text_document: The document to request symbols for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/documentSymbol\",\n        params={\"textDocument\": text_document.dict()},\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.exit","title":"<code>exit()</code>","text":"<p>Send an exit notification to the server.</p> <p>This method will send an exit notification to the server. After this notification is sent, the client will be in the <code>EXITED</code> state.</p> Source code in <code>tarts\\client.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Send an exit notification to the server.\n\n    This method will send an exit notification to the server. After this\n    notification is sent, the client will be in the `EXITED` state.\"\"\"\n    assert self._state == ClientState.SHUTDOWN\n    # TODO: figure out why params={} is needed\n    self._send_notification(method=\"exit\", params={})\n    self._state = ClientState.EXITED\n</code></pre>"},{"location":"api/client/#tarts.client.Client.folding_range","title":"<code>folding_range(text_document)</code>","text":"<p>Send a foldingRange request to the server.</p> <p>This method will send a foldingRange request to the server. This request is used to request folding ranges in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The document to request folding ranges for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def folding_range(self, text_document: TextDocumentIdentifier) -&gt; int:\n    \"\"\"Send a foldingRange request to the server.\n\n    This method will send a foldingRange request to the server. This request is\n    used to request folding ranges in a document.\n\n    Args:\n        text_document: The document to request folding ranges for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/foldingRange\",\n        params={\"textDocument\": text_document.dict()},\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.formatting","title":"<code>formatting(text_document, options)</code>","text":"<p>Send a formatting request to the server.</p> <p>This method will send a formatting request to the server. This request is used to request formatting for a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The document to request formatting for.</p> required <code>options</code> <code>FormattingOptions</code> <p>The options to use for formatting.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def formatting(\n    self, text_document: TextDocumentIdentifier, options: FormattingOptions\n) -&gt; int:\n    \"\"\"Send a formatting request to the server.\n\n    This method will send a formatting request to the server. This request is\n    used to request formatting for a document.\n\n    Args:\n        text_document: The document to request formatting for.\n        options: The options to use for formatting.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    params = {\"textDocument\": text_document.dict(), \"options\": options.dict()}\n    return self._send_request(method=\"textDocument/formatting\", params=params)\n</code></pre>"},{"location":"api/client/#tarts.client.Client.hover","title":"<code>hover(text_document_position)</code>","text":"<p>Send a hover request to the server.</p> <p>This method will send a hover request to the server. This request is used to request hover information at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request hover information for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def hover(self, text_document_position: TextDocumentPosition) -&gt; int:\n    \"\"\"Send a hover request to the server.\n\n    This method will send a hover request to the server. This request is\n    used to request hover information at a specific position in a document.\n\n    Args:\n        text_document_position: The position in the document to request\n            hover information for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/hover\", params=text_document_position.dict()\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.implementation","title":"<code>implementation(text_document_position)</code>","text":"<p>Send a implementation request to the server.</p> <p>This method will send a implementation request to the server. This request is used to request the implementation of a symbol at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request the implementation for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def implementation(self, text_document_position: TextDocumentPosition) -&gt; int:\n    \"\"\"Send a implementation request to the server.\n\n    This method will send a implementation request to the server. This request is\n    used to request the implementation of a symbol at a specific position in a\n    document.\n\n    Args:\n        text_document_position: The position in the document to request\n            the implementation for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/implementation\", params=text_document_position.dict()\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.inlay_hint","title":"<code>inlay_hint(text_document, range)</code>","text":"<p>Send a inlayHint request to the server.</p> <p>This method will send a inlayHint request to the server. This request is used to request inlay hints in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The document to request inlay hints for.</p> required <code>range</code> <code>Range</code> <p>The range to request inlay hints for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def inlay_hint(self, text_document: TextDocumentIdentifier, range: Range) -&gt; int:\n    \"\"\"Send a inlayHint request to the server.\n\n    This method will send a inlayHint request to the server. This request is\n    used to request inlay hints in a document.\n\n    Args:\n        text_document: The document to request inlay hints for.\n        range: The range to request inlay hints for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/inlayHint\",\n        params={\"textDocument\": text_document.dict(), \"range\": range.dict()},\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.prepareCallHierarchy","title":"<code>prepareCallHierarchy(text_document_position)</code>","text":"<p>Send a prepareCallHierarchy request to the server.</p> <p>This method will send a prepareCallHierarchy request to the server. This request is used to request call hierarchy information at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request call hierarchy information for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def prepareCallHierarchy(self, text_document_position: TextDocumentPosition) -&gt; int:\n    \"\"\"Send a prepareCallHierarchy request to the server.\n\n    This method will send a prepareCallHierarchy request to the server. This\n    request is used to request call hierarchy information at a specific position\n    in a document.\n\n    Args:\n        text_document_position: The position in the document to request\n            call hierarchy information for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/prepareCallHierarchy\",\n        params=text_document_position.dict(),\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.rangeFormatting","title":"<code>rangeFormatting(text_document, range, options)</code>","text":"<p>Send a rangeFormatting request to the server.</p> <p>This method will send a rangeFormatting request to the server. This request is used to request formatting for a range in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The document to request formatting for.</p> required <code>range</code> <code>Range</code> <p>The range to request formatting for.</p> required <code>options</code> <code>FormattingOptions</code> <p>The options to use for formatting.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def rangeFormatting(\n    self,\n    text_document: TextDocumentIdentifier,\n    range: Range,\n    options: FormattingOptions,\n) -&gt; int:\n    \"\"\"Send a rangeFormatting request to the server.\n\n    This method will send a rangeFormatting request to the server. This request\n    is used to request formatting for a range in a document.\n\n    Args:\n        text_document: The document to request formatting for.\n        range: The range to request formatting for.\n        options: The options to use for formatting.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    params = {\n        \"textDocument\": text_document.dict(),\n        \"range\": range.dict(),\n        \"options\": options.dict(),\n    }\n    return self._send_request(method=\"textDocument/rangeFormatting\", params=params)\n</code></pre>"},{"location":"api/client/#tarts.client.Client.recv","title":"<code>recv(data)</code>","text":"<p>Feed data received from the server back into the client.</p> <p>This method will parse the data received from the server, and yield any events that are generated by the data. If the data is not enough to generate a full event, the data will be saved until enough data is received.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The data received from the server.</p> required <p>Yields:</p> Type Description <code>Event</code> <p>The events generated by the data.</p> Source code in <code>tarts\\client.py</code> <pre><code>def recv(self, data: bytes) -&gt; t.Iterator[Event]:\n    \"\"\"Feed data received from the server back into the client.\n\n    This method will parse the data received from the server, and yield any\n    events that are generated by the data. If the data is not enough to\n    generate a full event, the data will be saved until enough data is\n    received.\n\n    Args:\n        data: The data received from the server.\n\n    Yields:\n        The events generated by the data.\"\"\"\n    self._recv_buf += data\n    # Make sure to use lots of iterators, so that if one message fails to\n    # parse, the messages before it are yielded successfully before the\n    # error, and the messages after it are left in _recv_buf.\n    for message in _parse_messages(self._recv_buf):\n        if isinstance(message, Response):\n            yield self._handle_response(message)\n        else:\n            yield self._handle_request(message)\n</code></pre>"},{"location":"api/client/#tarts.client.Client.references","title":"<code>references(text_document_position)</code>","text":"<p>Send a references request to the server.</p> <p>This method will send a references request to the server. This request is used to request references to a symbol at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request references for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def references(self, text_document_position: TextDocumentPosition) -&gt; int:\n    \"\"\"Send a references request to the server.\n\n    This method will send a references request to the server. This request is\n    used to request references to a symbol at a specific position in a\n    document.\n\n    Args:\n        text_document_position: The position in the document to request\n            references for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    params = {\n        \"context\": {\"includeDeclaration\": True},\n        **text_document_position.dict(),\n    }\n    return self._send_request(method=\"textDocument/references\", params=params)\n</code></pre>"},{"location":"api/client/#tarts.client.Client.rename","title":"<code>rename(text_document_position, new_name)</code>","text":"<p>Send a rename request to the server.</p> <p>This method will send a rename request to the server. This request is used to request that the server rename a symbol in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to rename.</p> required <code>new_name</code> <code>str</code> <p>The new name of the symbol.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def rename(\n    self,\n    text_document_position: TextDocumentPosition,\n    new_name: str,\n) -&gt; int:\n    \"\"\"Send a rename request to the server.\n\n    This method will send a rename request to the server. This request is\n    used to request that the server rename a symbol in a document.\n\n    Args:\n        text_document_position: The position in the document to rename.\n        new_name: The new name of the symbol.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    params = {}\n    params.update(text_document_position.dict())\n    params[\"newName\"] = new_name\n    return self._send_request(method=\"textDocument/rename\", params=params)\n</code></pre>"},{"location":"api/client/#tarts.client.Client.send","title":"<code>send()</code>","text":"<p>Get the bytes to send to the server.</p> <p>This method will return the bytes that need to be sent to the server. This is the main way to interact with the client.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The bytes to send to the server.</p> Source code in <code>tarts\\client.py</code> <pre><code>def send(self) -&gt; bytes:\n    \"\"\"Get the bytes to send to the server.\n\n    This method will return the bytes that need to be sent to the server.\n    This is the main way to interact with the client.\n\n    Returns:\n        The bytes to send to the server.\n    \"\"\"\n\n    send_buf = self._send_buf[:]\n    self._send_buf.clear()\n    return send_buf\n</code></pre>"},{"location":"api/client/#tarts.client.Client.shutdown","title":"<code>shutdown()</code>","text":"<p>Send a shutdown request to the server.</p> <p>This method will send a shutdown request to the server. After this request is sent, the client will be in the <code>WAITING_FOR_SHUTDOWN</code> state.</p> Source code in <code>tarts\\client.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Send a shutdown request to the server.\n\n    This method will send a shutdown request to the server. After this\n    request is sent, the client will be in the `WAITING_FOR_SHUTDOWN` state.\"\"\"\n\n    assert self._state == ClientState.NORMAL\n    self._send_request(method=\"shutdown\")\n    self._state = ClientState.WAITING_FOR_SHUTDOWN\n</code></pre>"},{"location":"api/client/#tarts.client.Client.signatureHelp","title":"<code>signatureHelp(text_document_position)</code>","text":"<p>Send a signatureHelp request to the server.</p> <p>This method will send a signatureHelp request to the server. This request is used to request signature help at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request signature help for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def signatureHelp(self, text_document_position: TextDocumentPosition) -&gt; int:\n    \"\"\"Send a signatureHelp request to the server.\n\n    This method will send a signatureHelp request to the server. This request is\n    used to request signature help at a specific position in a document.\n\n    Args:\n        text_document_position: The position in the document to request\n            signature help for.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/signatureHelp\", params=text_document_position.dict()\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.typeDefinition","title":"<code>typeDefinition(text_document_position)</code>","text":"<p>Send a typeDefinition request to the server.</p> <p>This method will send a typeDefinition request to the server. This request is used to request the type definition of a symbol at a specific position in a document.</p> <p>Parameters:</p> Name Type Description Default <code>text_document_position</code> <code>TextDocumentPosition</code> <p>The position in the document to request the type definition for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def typeDefinition(self, text_document_position: TextDocumentPosition) -&gt; int:\n    \"\"\"Send a typeDefinition request to the server.\n\n    This method will send a typeDefinition request to the server. This request is\n    used to request the type definition of a symbol at a specific position in a\n    document.\n\n    Args:\n        text_document_position: The position in the document to request\n            the type definition for.\n\n    Returns:\n        The ID of the request.\"\"\"\n    assert self._state == ClientState.NORMAL\n    return self._send_request(\n        method=\"textDocument/typeDefinition\", params=text_document_position.dict()\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.will_save","title":"<code>will_save(text_document, reason)</code>","text":"<p>Send a willSave notification to the server.</p> <p>This method will send a willSave notification to the server. This notification is used to inform the server that a document will be saved.</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The text document that will be saved.</p> required <code>reason</code> <code>TextDocumentSaveReason</code> <p>The reason the document will be saved.</p> required Source code in <code>tarts\\client.py</code> <pre><code>def will_save(\n    self, text_document: TextDocumentIdentifier, reason: TextDocumentSaveReason\n) -&gt; None:\n    \"\"\"Send a willSave notification to the server.\n\n    This method will send a willSave notification to the server. This\n    notification is used to inform the server that a document will be saved.\n\n    Args:\n        text_document: The text document that will be saved.\n        reason: The reason the document will be saved.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    self._send_notification(\n        method=\"textDocument/willSave\",\n        params={\"textDocument\": text_document.dict(), \"reason\": reason.value},\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.will_save_wait_until","title":"<code>will_save_wait_until(text_document, reason)</code>","text":"<p>Send a willSaveWaitUntil request to the server.</p> <p>This method will send a willSaveWaitUntil request to the server. This</p> <p>Parameters:</p> Name Type Description Default <code>text_document</code> <code>TextDocumentIdentifier</code> <p>The text document that will be saved.</p> required <code>reason</code> <code>TextDocumentSaveReason</code> <p>The reason the document will be saved.</p> required Source code in <code>tarts\\client.py</code> <pre><code>def will_save_wait_until(\n    self, text_document: TextDocumentIdentifier, reason: TextDocumentSaveReason\n) -&gt; None:\n    \"\"\"Send a willSaveWaitUntil request to the server.\n\n    This method will send a willSaveWaitUntil request to the server. This\n\n    Args:\n        text_document: The text document that will be saved.\n        reason: The reason the document will be saved.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    self._send_request(\n        method=\"textDocument/willSaveWaitUntil\",\n        params={\"textDocument\": text_document.dict(), \"reason\": reason.value},\n    )\n</code></pre>"},{"location":"api/client/#tarts.client.Client.workspace_symbol","title":"<code>workspace_symbol(query='')</code>","text":"<p>Send a workspace/symbol request to the server.</p> <p>This method will send a workspace/symbol request to the server. This request is used to request symbols in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to filter symbols by.</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the request.</p> Source code in <code>tarts\\client.py</code> <pre><code>def workspace_symbol(self, query: str = \"\") -&gt; int:\n    \"\"\"Send a workspace/symbol request to the server.\n\n    This method will send a workspace/symbol request to the server. This request\n    is used to request symbols in the workspace.\n\n    Args:\n        query: The query to filter symbols by.\n\n    Returns:\n        The ID of the request.\n    \"\"\"\n\n    assert self._state == ClientState.NORMAL\n    return self._send_request(method=\"workspace/symbol\", params={\"query\": query})\n</code></pre>"},{"location":"api/events/","title":"API Reference","text":""},{"location":"api/events/#events","title":"Events","text":""},{"location":"api/events/#tarts.events.Completion","title":"<code>Completion</code>","text":"<p>               Bases: <code>Event</code></p> <p>The completion request is sent from the client to the server to compute completion items at a given cursor position.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>completion_list</code> <code>Optional[CompletionList]</code> <p>The completion list.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class Completion(Event):\n    \"\"\"The completion request is sent from the client to the server to compute completion items at a given cursor position.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        completion_list (Optional[CompletionList]): The completion list.\n    \"\"\"\n\n    message_id: Id\n    completion_list: t.Optional[CompletionList]\n</code></pre>"},{"location":"api/events/#tarts.events.ConfigurationRequest","title":"<code>ConfigurationRequest</code>","text":"<p>               Bases: <code>ServerRequest</code></p> <p>The configuration request is sent from the client to the server to fetch configuration settings.</p> <p>Methods:</p> Name Description <code>reply</code> <p>Reply to the ConfigurationRequest with configuration items.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>List[ConfigurationItem]</code> <p>The configuration items.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class ConfigurationRequest(ServerRequest):\n    \"\"\"The configuration request is sent from the client to the server to fetch configuration settings.\n\n    Methods:\n        reply: Reply to the ConfigurationRequest with configuration items.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (List[ConfigurationItem]): The configuration items.\n    \"\"\"\n\n    items: t.List[ConfigurationItem]\n\n    def reply(self, result: t.List[t.Any] = []) -&gt; None:\n        \"\"\"\n        Reply to the ConfigurationRequest with configuration items.\n\n        No bytes are actually returned from this method, the reply's bytes\n        are added to the client's internal send buffer.\n        \"\"\"\n        self._client._send_response(id=self._id, result=result)\n</code></pre>"},{"location":"api/events/#tarts.events.ConfigurationRequest.reply","title":"<code>reply(result=[])</code>","text":"<p>Reply to the ConfigurationRequest with configuration items.</p> <p>No bytes are actually returned from this method, the reply's bytes are added to the client's internal send buffer.</p> Source code in <code>tarts\\events.py</code> <pre><code>def reply(self, result: t.List[t.Any] = []) -&gt; None:\n    \"\"\"\n    Reply to the ConfigurationRequest with configuration items.\n\n    No bytes are actually returned from this method, the reply's bytes\n    are added to the client's internal send buffer.\n    \"\"\"\n    self._client._send_response(id=self._id, result=result)\n</code></pre>"},{"location":"api/events/#tarts.events.Declaration","title":"<code>Declaration</code>","text":"<p>               Bases: <code>Event</code></p> <p>The declaration request is sent from the client to the server to resolve the declaration location of a symbol at a given text document position.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>Union[Location, List[Union[Location, LocationLink]], None]</code> <p>The declaration location.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class Declaration(Event):\n    \"\"\"The declaration request is sent from the client to the server to resolve the declaration location of a symbol at a given text document position.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (Union[Location, List[Union[Location, LocationLink]], None]): The declaration location.\n    \"\"\"\n\n    result: t.Union[Location, t.List[t.Union[Location, LocationLink]], None]\n</code></pre>"},{"location":"api/events/#tarts.events.Definition","title":"<code>Definition</code>","text":"<p>               Bases: <code>Event</code></p> <p>The definition request is sent from the client to the server to resolve the definition location of a symbol at a given text document position.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>Union[Location, List[Union[Location, LocationLink]], None]</code> <p>The definition location.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class Definition(Event):\n    \"\"\"The definition request is sent from the client to the server to resolve the definition location of a symbol at a given text document position.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (Union[Location, List[Union[Location, LocationLink]], None]): The definition location.\n    \"\"\"\n\n    message_id: t.Optional[Id]\n    result: t.Union[Location, t.List[t.Union[Location, LocationLink]], None]\n</code></pre>"},{"location":"api/events/#tarts.events.DocumentFormatting","title":"<code>DocumentFormatting</code>","text":"<p>               Bases: <code>Event</code></p> <p>The document formatting request is sent from the client to the server to format a whole document.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>List[TextEdit]</code> <p>The text edits.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class DocumentFormatting(Event):\n    \"\"\"The document formatting request is sent from the client to the server to format a whole document.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (List[TextEdit]): The text edits.\n    \"\"\"\n\n    message_id: t.Optional[Id]\n    result: t.Union[t.List[TextEdit], None]\n</code></pre>"},{"location":"api/events/#tarts.events.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all events.</p> Source code in <code>tarts\\events.py</code> <pre><code>class Event(BaseModel):\n    \"\"\"Base class for all events.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/events/#tarts.events.Hover","title":"<code>Hover</code>","text":"<p>               Bases: <code>Event</code></p> <p>The hover request is sent from the client to the server to request hover information at a given text document position.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>contents</code> <code>Union[List[Union[MarkedString, str]], MarkedString, MarkupContent, str]</code> <p>The hover contents.</p> required <code>range</code> <code>Optional[Range]</code> <p>The hover range.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class Hover(Event):\n    \"\"\"The hover request is sent from the client to the server to request hover information at a given text document position.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        contents (Union[List[Union[MarkedString, str]], MarkedString, MarkupContent, str]): The hover contents.\n        range (Optional[Range]): The hover range.\n    \"\"\"\n\n    message_id: t.Optional[Id]  # custom...\n    contents: t.Union[\n        t.List[t.Union[MarkedString, str]], MarkedString, MarkupContent, str\n    ]\n    range: t.Optional[Range]\n</code></pre>"},{"location":"api/events/#tarts.events.Implementation","title":"<code>Implementation</code>","text":"<p>               Bases: <code>Event</code></p> <p>The implementation request is sent from the client to the server to resolve the implementation location of a symbol at a given text document position.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>Union[Location, List[Union[Location, LocationLink]], None]</code> <p>The implementation location.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class Implementation(Event):\n    \"\"\"The implementation request is sent from the client to the server to resolve the implementation location of a symbol at a given text document position.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (Union[Location, List[Union[Location, LocationLink]], None]): The implementation location.\n    \"\"\"\n\n    result: t.Union[Location, t.List[t.Union[Location, LocationLink]], None]\n</code></pre>"},{"location":"api/events/#tarts.events.Initialized","title":"<code>Initialized</code>","text":"<p>               Bases: <code>Event</code></p> <p>The initialized notification is sent from the client to the server after the client received the result of the initialize request but before the client is sending any other request or notification to the server.</p> <p>Parameters:</p> Name Type Description Default <code>capabilities</code> <code>JSONDict</code> <p>The capabilities of the client (editor).</p> required Source code in <code>tarts\\events.py</code> <pre><code>class Initialized(Event):\n    \"\"\"The initialized notification is sent from the client to the server after the client received the result\n    of the initialize request but before the client is sending any other request or notification to the server.\n\n    Args:\n        capabilities (JSONDict): The capabilities of the client (editor).\n    \"\"\"\n\n    capabilities: JSONDict\n</code></pre>"},{"location":"api/events/#tarts.events.LogMessage","title":"<code>LogMessage</code>","text":"<p>               Bases: <code>ServerNotification</code></p> <p>The log message notification is sent from the server to the client to ask the client to log a particular message.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>MessageType</code> <p>The message type.</p> required <code>message</code> <code>str</code> <p>The message to be logged.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class LogMessage(ServerNotification):\n    \"\"\"The log message notification is sent from the server to the client to ask the client to log a particular message.\n\n    Args:\n        type (MessageType): The message type.\n        message (str): The message to be logged.\n    \"\"\"\n\n    type: MessageType\n    message: str\n</code></pre>"},{"location":"api/events/#tarts.events.MCallHierarchItems","title":"<code>MCallHierarchItems</code>","text":"<p>               Bases: <code>Event</code></p> <p>The call hierarchy request is sent from the client to the server to resolve items for a given text document position.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>Union[List[CallHierarchyItem], None]</code> <p>The call hierarchy items.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class MCallHierarchItems(Event):\n    \"\"\"The call hierarchy request is sent from the client to the server to resolve items for a given text document position.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (Union[List[CallHierarchyItem], None]): The call hierarchy items.\n    \"\"\"\n\n    result: t.Union[t.List[CallHierarchyItem], None]\n</code></pre>"},{"location":"api/events/#tarts.events.MDocumentSymbols","title":"<code>MDocumentSymbols</code>","text":"<p>               Bases: <code>Event</code></p> <p>The document symbols request is sent from the client to the server to return symbols of a given text document.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>Union[List[SymbolInformation], List[DocumentSymbol], None]</code> <p>The symbols.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class MDocumentSymbols(Event):\n    \"\"\"The document symbols request is sent from the client to the server to return symbols of a given text document.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (Union[List[SymbolInformation], List[DocumentSymbol], None]): The symbols.\n    \"\"\"\n\n    message_id: t.Optional[Id]\n    result: t.Union[t.List[SymbolInformation], t.List[DocumentSymbol], None]\n</code></pre>"},{"location":"api/events/#tarts.events.MFoldingRanges","title":"<code>MFoldingRanges</code>","text":"<p>               Bases: <code>Event</code></p> <p>The folding ranges request is sent from the client to the server to return all folding ranges found in a given text document.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>List[FoldingRange]</code> <p>The folding ranges.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class MFoldingRanges(Event):\n    \"\"\"The folding ranges request is sent from the client to the server to return all folding ranges found in a given text document.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (List[FoldingRange]): The folding ranges.\n    \"\"\"\n\n    message_id: t.Optional[Id]\n    result: t.Optional[t.List[FoldingRange]]\n</code></pre>"},{"location":"api/events/#tarts.events.MInlayHints","title":"<code>MInlayHints</code>","text":"<p>               Bases: <code>Event</code></p> <p>The inlay hints request is sent from the client to the server to return inlay hints for a specific file.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>List[InlayHint]</code> <p>The inlay hints.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class MInlayHints(Event):\n    \"\"\"The inlay hints request is sent from the client to the server to return inlay hints for a specific file.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (List[InlayHint]): The inlay hints.\n    \"\"\"\n\n    message_id: t.Optional[Id]\n    result: t.Optional[t.List[InlayHint]]\n</code></pre>"},{"location":"api/events/#tarts.events.MWorkspaceSymbols","title":"<code>MWorkspaceSymbols</code>","text":"<p>               Bases: <code>Event</code></p> <p>The workspace symbols request is sent from the client to the server to list project-wide symbols matching the query string.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>List[SymbolInformation]</code> <p>The symbols.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class MWorkspaceSymbols(Event):\n    \"\"\"The workspace symbols request is sent from the client to the server to list project-wide symbols matching the query string.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (List[SymbolInformation]): The symbols.\n    \"\"\"\n\n    result: t.Union[t.List[SymbolInformation], None]\n</code></pre>"},{"location":"api/events/#tarts.events.Progress","title":"<code>Progress</code>","text":"<p>               Bases: <code>ServerNotification</code></p> <p>Base class for all progress notifications.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>ProgressToken</code> <p>The progress token.</p> required <code>value</code> <code>ProgressValue</code> <p>The progress value.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class Progress(ServerNotification):\n    \"\"\"Base class for all progress notifications.\n\n    Args:\n        token (ProgressToken): The progress token.\n        value (ProgressValue): The progress value.\n    \"\"\"\n\n    token: ProgressToken\n    value: ProgressValue\n</code></pre>"},{"location":"api/events/#tarts.events.PublishDiagnostics","title":"<code>PublishDiagnostics</code>","text":"<p>               Bases: <code>ServerNotification</code></p> <p>The publish diagnostics notification is sent from the server to the client to signal results of validation runs.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI for which diagnostic information is reported.</p> required <code>version</code> <code>Optional[int]</code> <p>The version number of the document the diagnostics are published for.</p> required <code>diagnostics</code> <code>List[Diagnostic]</code> <p>The diagnostics.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class PublishDiagnostics(ServerNotification):\n    \"\"\"The publish diagnostics notification is sent from the server to the client to signal results of validation runs.\n\n    Args:\n        uri (str): The URI for which diagnostic information is reported.\n        version (Optional[int]): The version number of the document the diagnostics are published for.\n        diagnostics (List[Diagnostic]): The diagnostics.\n    \"\"\"\n\n    uri: str\n    version: t.Optional[int]\n    diagnostics: t.List[Diagnostic]\n</code></pre>"},{"location":"api/events/#tarts.events.References","title":"<code>References</code>","text":"<p>               Bases: <code>Event</code></p> <p>The references request is sent from the client to the server to resolve project-wide references for the symbol denoted by the given text document position.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>List[Location]</code> <p>The references.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class References(Event):\n    \"\"\"The references request is sent from the client to the server to resolve project-wide references for the symbol denoted by the given text document position.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (List[Location]): The references.\n    \"\"\"\n\n    result: t.Union[t.List[Location], None]\n</code></pre>"},{"location":"api/events/#tarts.events.RegisterCapabilityRequest","title":"<code>RegisterCapabilityRequest</code>","text":"<p>               Bases: <code>ServerRequest</code></p> <p>The register capability request is sent from the client to the server to register a capability.</p> <p>Methods:</p> Name Description <code>reply</code> <p>Reply to the RegisterCapabilityRequest.</p> <p>Parameters:</p> Name Type Description Default <code>registrations</code> <code>List[Registration]</code> <p>The registrations.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class RegisterCapabilityRequest(ServerRequest):\n    \"\"\"The register capability request is sent from the client to the server to register a capability.\n\n    Methods:\n        reply: Reply to the RegisterCapabilityRequest.\n\n    Args:\n        registrations (List[Registration]): The registrations.\n    \"\"\"\n\n    registrations: t.List[Registration]\n\n    def reply(self) -&gt; None:\n        \"\"\"Reply to the RegisterCapabilityRequest.\"\"\"\n        self._client._send_response(id=self._id, result={})\n</code></pre>"},{"location":"api/events/#tarts.events.RegisterCapabilityRequest.reply","title":"<code>reply()</code>","text":"<p>Reply to the RegisterCapabilityRequest.</p> Source code in <code>tarts\\events.py</code> <pre><code>def reply(self) -&gt; None:\n    \"\"\"Reply to the RegisterCapabilityRequest.\"\"\"\n    self._client._send_response(id=self._id, result={})\n</code></pre>"},{"location":"api/events/#tarts.events.ResponseError","title":"<code>ResponseError</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base class for all response errors.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>code</code> <code>int</code> <p>The error code.</p> required <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>Union[str, int, float, bool, List[Any], Dict[str, Any], None]</code> <p>The error data.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class ResponseError(Event):\n    \"\"\"Base class for all response errors.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        code (int): The error code.\n        message (str): The error message.\n        data (Union[str, int, float, bool, List[Any], Dict[str, Any], None]): The error data.\n    \"\"\"\n\n    message_id: t.Optional[Id]\n    code: int\n    message: str\n    data: t.Optional[t.Union[str, int, float, bool, t.List[t.Any], JSONDict, None]]\n</code></pre>"},{"location":"api/events/#tarts.events.ServerNotification","title":"<code>ServerNotification</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base class for all server notifications.</p> Source code in <code>tarts\\events.py</code> <pre><code>class ServerNotification(Event):\n    \"\"\"Base class for all server notifications.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/events/#tarts.events.ServerRequest","title":"<code>ServerRequest</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base class for all server requests.</p> <p>Parameters:</p> Name Type Description Default <code>_client</code> <code>Client</code> <p>The client instance.</p> required <code>_id</code> <code>Id</code> <p>The request ID.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class ServerRequest(Event):\n    \"\"\"Base class for all server requests.\n\n    Args:\n        _client (Client): The client instance.\n        _id (Id): The request ID.\n    \"\"\"\n\n    _client: Client = PrivateAttr()\n    _id: Id = PrivateAttr()\n</code></pre>"},{"location":"api/events/#tarts.events.ShowMessage","title":"<code>ShowMessage</code>","text":"<p>               Bases: <code>ServerNotification</code></p> <p>The show message notification is sent from a server to a client to ask the client to display a particular message in the user interface.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>MessageType</code> <p>The message type.</p> required <code>message</code> <code>str</code> <p>The message to be shown.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class ShowMessage(ServerNotification):\n    \"\"\"The show message notification is sent from a server to a client to ask the client to display a particular message\n    in the user interface.\n\n    Args:\n        type (MessageType): The message type.\n        message (str): The message to be shown.\n    \"\"\"\n\n    type: MessageType\n    message: str\n</code></pre>"},{"location":"api/events/#tarts.events.ShowMessageRequest","title":"<code>ShowMessageRequest</code>","text":"<p>               Bases: <code>ServerRequest</code></p> <p>The show message request is sent from a server to a client to ask the client to display a particular message in the user interface.</p> <p>Methods:</p> Name Description <code>reply</code> <p>Reply to the ShowMessageRequest with the user's selection.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>MessageType</code> <p>The message type.</p> required <code>message</code> <code>str</code> <p>The message to be shown.</p> required <code>actions</code> <code>Optional[List[MessageActionItem]]</code> <p>The actions to be shown.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class ShowMessageRequest(ServerRequest):\n    \"\"\"The show message request is sent from a server to a client to ask the client to display a particular message\n    in the user interface.\n\n    Methods:\n        reply: Reply to the ShowMessageRequest with the user's selection.\n\n    Args:\n        type (MessageType): The message type.\n        message (str): The message to be shown.\n        actions (Optional[List[MessageActionItem]]): The actions to be shown.\n    \"\"\"\n\n    type: MessageType\n    message: str\n    actions: t.Optional[t.List[MessageActionItem]]\n\n    def reply(self, action: t.Optional[MessageActionItem] = None) -&gt; None:\n        \"\"\"\n        Reply to the ShowMessageRequest with the user's selection.\n\n        No bytes are actually returned from this method, the reply's bytes\n        are added to the client's internal send buffer.\n        \"\"\"\n        self._client._send_response(\n            id=self._id, result=action.dict() if action is not None else None\n        )\n</code></pre>"},{"location":"api/events/#tarts.events.ShowMessageRequest.reply","title":"<code>reply(action=None)</code>","text":"<p>Reply to the ShowMessageRequest with the user's selection.</p> <p>No bytes are actually returned from this method, the reply's bytes are added to the client's internal send buffer.</p> Source code in <code>tarts\\events.py</code> <pre><code>def reply(self, action: t.Optional[MessageActionItem] = None) -&gt; None:\n    \"\"\"\n    Reply to the ShowMessageRequest with the user's selection.\n\n    No bytes are actually returned from this method, the reply's bytes\n    are added to the client's internal send buffer.\n    \"\"\"\n    self._client._send_response(\n        id=self._id, result=action.dict() if action is not None else None\n    )\n</code></pre>"},{"location":"api/events/#tarts.events.Shutdown","title":"<code>Shutdown</code>","text":"<p>               Bases: <code>Event</code></p> <p>The shutdown request is sent from the client to the server. It asks the server to shut down.</p> Source code in <code>tarts\\events.py</code> <pre><code>class Shutdown(Event):\n    \"\"\"The shutdown request is sent from the client to the server. It asks the server to shut down.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/events/#tarts.events.SignatureHelp","title":"<code>SignatureHelp</code>","text":"<p>               Bases: <code>Event</code></p> <p>The signature help request is sent from the client to the server to request signature information at a given cursor position.</p> <p>Methods:</p> Name Description <code>get_hint_str</code> <p>Get the signature help hint string.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>signatures</code> <code>List[SignatureInformation]</code> <p>The signatures.</p> required <code>activeSignature</code> <code>Optional[int]</code> <p>The active signature.</p> required <code>activeParameter</code> <code>Optional[int]</code> <p>The active parameter.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class SignatureHelp(Event):\n    \"\"\"The signature help request is sent from the client to the server to request signature information at a given cursor position.\n\n    Methods:\n        get_hint_str: Get the signature help hint string.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        signatures (List[SignatureInformation]): The signatures.\n        activeSignature (Optional[int]): The active signature.\n        activeParameter (Optional[int]): The active parameter.\n    \"\"\"\n\n    message_id: t.Optional[Id]  # custom...\n    signatures: t.List[SignatureInformation]\n    activeSignature: t.Optional[int]\n    activeParameter: t.Optional[int]\n\n    def get_hint_str(self) -&gt; t.Optional[str]:\n        \"\"\"Get the signature help hint string.\"\"\"\n\n        if len(self.signatures) == 0:\n            return None\n        active_sig = self.activeSignature or 0\n        sig = self.signatures[active_sig]\n        return sig.label\n</code></pre>"},{"location":"api/events/#tarts.events.SignatureHelp.get_hint_str","title":"<code>get_hint_str()</code>","text":"<p>Get the signature help hint string.</p> Source code in <code>tarts\\events.py</code> <pre><code>def get_hint_str(self) -&gt; t.Optional[str]:\n    \"\"\"Get the signature help hint string.\"\"\"\n\n    if len(self.signatures) == 0:\n        return None\n    active_sig = self.activeSignature or 0\n    sig = self.signatures[active_sig]\n    return sig.label\n</code></pre>"},{"location":"api/events/#tarts.events.TypeDefinition","title":"<code>TypeDefinition</code>","text":"<p>               Bases: <code>Event</code></p> <p>The type definition request is sent from the client to the server to resolve the type definition location of a symbol at a given text document position.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>Union[Location, List[Union[Location, LocationLink]], None]</code> <p>The type definition location.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class TypeDefinition(Event):\n    \"\"\"The type definition request is sent from the client to the server to resolve the type definition location of a symbol at a given text document position.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (Union[Location, List[Union[Location, LocationLink]], None]): The type definition location.\n    \"\"\"\n\n    result: t.Union[Location, t.List[t.Union[Location, LocationLink]], None]\n</code></pre>"},{"location":"api/events/#tarts.events.WillSaveWaitUntilEdits","title":"<code>WillSaveWaitUntilEdits</code>","text":"<p>               Bases: <code>Event</code></p> <p>The will save wait until edits request is sent from the client to the server before the document is actually saved.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>edits</code> <code>Optional[List[TextEdit]]</code> <p>The edits.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class WillSaveWaitUntilEdits(Event):\n    \"\"\"The will save wait until edits request is sent from the client to the server before the document is actually saved.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        edits (Optional[List[TextEdit]]): The edits.\n    \"\"\"\n\n    edits: t.Optional[t.List[TextEdit]]\n</code></pre>"},{"location":"api/events/#tarts.events.WorkDoneProgress","title":"<code>WorkDoneProgress</code>","text":"<p>               Bases: <code>Progress</code></p> <p>Base class for all work done progress notifications.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>ProgressToken</code> <p>The progress token.</p> required <code>value</code> <code>ProgressValue</code> <p>The progress value.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class WorkDoneProgress(Progress):\n    \"\"\"Base class for all work done progress notifications.\n\n    Args:\n        token (ProgressToken): The progress token.\n        value (ProgressValue): The progress value.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/events/#tarts.events.WorkDoneProgressBegin","title":"<code>WorkDoneProgressBegin</code>","text":"<p>               Bases: <code>WorkDoneProgress</code></p> <p>The work done progress begin notification is sent from the server to the client to begin a progress.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>WorkDoneProgressBeginValue</code> <p>The progress value.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class WorkDoneProgressBegin(WorkDoneProgress):\n    \"\"\"The work done progress begin notification is sent from the server to the client to begin a progress.\n\n    Args:\n        value (WorkDoneProgressBeginValue): The progress value.\n    \"\"\"\n\n    value: WorkDoneProgressBeginValue\n</code></pre>"},{"location":"api/events/#tarts.events.WorkDoneProgressCreate","title":"<code>WorkDoneProgressCreate</code>","text":"<p>               Bases: <code>ServerRequest</code></p> <p>The work done progress create request is sent from the server to the client to ask the client to create a work done progress.</p> <p>Methods:</p> Name Description <code>reply</code> <p>Reply to the WorkDoneProgressCreate request.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>ProgressToken</code> <p>The progress token.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class WorkDoneProgressCreate(ServerRequest):\n    \"\"\"The work done progress create request is sent from the server to the client to ask the client to create a\n    work done progress.\n\n    Methods:\n        reply: Reply to the WorkDoneProgressCreate request.\n\n    Args:\n        token (ProgressToken): The progress token.\"\"\"\n\n    token: ProgressToken\n\n    def reply(self) -&gt; None:\n        \"\"\"Reply to the WorkDoneProgressCreate request.\"\"\"\n\n        self._client._send_response(id=self._id, result=None)\n</code></pre>"},{"location":"api/events/#tarts.events.WorkDoneProgressCreate.reply","title":"<code>reply()</code>","text":"<p>Reply to the WorkDoneProgressCreate request.</p> Source code in <code>tarts\\events.py</code> <pre><code>def reply(self) -&gt; None:\n    \"\"\"Reply to the WorkDoneProgressCreate request.\"\"\"\n\n    self._client._send_response(id=self._id, result=None)\n</code></pre>"},{"location":"api/events/#tarts.events.WorkDoneProgressEnd","title":"<code>WorkDoneProgressEnd</code>","text":"<p>               Bases: <code>WorkDoneProgress</code></p> <p>The work done progress end notification is sent from the server to the client to end a progress.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>WorkDoneProgressEndValue</code> <p>The progress value.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class WorkDoneProgressEnd(WorkDoneProgress):\n    \"\"\"The work done progress end notification is sent from the server to the client to end a progress.\n\n    Args:\n        value (WorkDoneProgressEndValue): The progress value.\n    \"\"\"\n\n    value: WorkDoneProgressEndValue\n</code></pre>"},{"location":"api/events/#tarts.events.WorkDoneProgressReport","title":"<code>WorkDoneProgressReport</code>","text":"<p>               Bases: <code>WorkDoneProgress</code></p> <p>The work done progress report notification is sent from the server to the client to report progress.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>WorkDoneProgressReportValue</code> <p>The progress value.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class WorkDoneProgressReport(WorkDoneProgress):\n    \"\"\"The work done progress report notification is sent from the server to the client to report progress.\n\n    Args:\n        value (WorkDoneProgressReportValue): The progress value.\n    \"\"\"\n\n    value: WorkDoneProgressReportValue\n</code></pre>"},{"location":"api/events/#tarts.events.WorkspaceEdit","title":"<code>WorkspaceEdit</code>","text":"<p>               Bases: <code>Event</code></p> <p>The workspace edit is sent from the server to the client to modify resource on the client side.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>changes</code> <code>Optional[Dict[str, List[TextEdit]]]</code> <p>The changes.</p> required <code>documentChanges</code> <code>Optional[List[TextDocumentEdit]]</code> <p>The document changes.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class WorkspaceEdit(Event):\n    \"\"\"The workspace edit is sent from the server to the client to modify resource on the client side.\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        changes (Optional[Dict[str, List[TextEdit]]]): The changes.\n        documentChanges (Optional[List[TextDocumentEdit]]): The document changes.\n    \"\"\"\n\n    message_id: t.Optional[Id]\n    changes: t.Optional[t.Dict[str, TextEdit]]\n    documentChanges: t.Optional[t.List[TextDocumentEdit]]\n</code></pre>"},{"location":"api/events/#tarts.events.WorkspaceFolders","title":"<code>WorkspaceFolders</code>","text":"<p>               Bases: <code>ServerRequest</code></p> <p>The workspace folders request is sent from the client to the server to fetch the workspace folders.</p> <p>Methods:</p> Name Description <code>reply</code> <p>Reply to the WorkspaceFolders with workspace</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[Id]</code> <p>The message ID.</p> required <code>result</code> <code>Optional[List[WorkspaceFolder]]</code> <p>The workspace folders.</p> required Source code in <code>tarts\\events.py</code> <pre><code>class WorkspaceFolders(ServerRequest):\n    \"\"\"The workspace folders request is sent from the client to the server to fetch the workspace folders.\n\n    Methods:\n        reply: Reply to the WorkspaceFolders with workspace\n\n    Args:\n        message_id (Optional[Id]): The message ID.\n        result (Optional[List[WorkspaceFolder]]): The workspace folders.\n    \"\"\"\n\n    result: t.Optional[t.List[WorkspaceFolder]]\n\n    def reply(self, folders: t.Optional[t.List[WorkspaceFolder]] = None) -&gt; None:\n        \"\"\"\n        Reply to the WorkspaceFolder with workspace folders.\n\n        No bytes are actually returned from this method, the reply's bytes\n        are added to the client's internal send buffer.\n        \"\"\"\n        self._client._send_response(\n            id=self._id,\n            result=[f.dict() for f in folders] if folders is not None else None,\n        )\n</code></pre>"},{"location":"api/events/#tarts.events.WorkspaceFolders.reply","title":"<code>reply(folders=None)</code>","text":"<p>Reply to the WorkspaceFolder with workspace folders.</p> <p>No bytes are actually returned from this method, the reply's bytes are added to the client's internal send buffer.</p> Source code in <code>tarts\\events.py</code> <pre><code>def reply(self, folders: t.Optional[t.List[WorkspaceFolder]] = None) -&gt; None:\n    \"\"\"\n    Reply to the WorkspaceFolder with workspace folders.\n\n    No bytes are actually returned from this method, the reply's bytes\n    are added to the client's internal send buffer.\n    \"\"\"\n    self._client._send_response(\n        id=self._id,\n        result=[f.dict() for f in folders] if folders is not None else None,\n    )\n</code></pre>"},{"location":"api/structs/","title":"API Reference","text":""},{"location":"api/structs/#tarts.structs.CallHierarchyIncomingCall","title":"<code>CallHierarchyIncomingCall</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an incoming call, as part of the call hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>from_</code> <code>CallHierarchyItem</code> <p>The item that makes the call.</p> required <code>fromRanges</code> <code>List[Range]</code> <p>The ranges at which the calls appear.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class CallHierarchyIncomingCall(BaseModel):\n    \"\"\"Represents an incoming call, as part of the call hierarchy.\n\n    Args:\n        from_ (CallHierarchyItem): The item that makes the call.\n        fromRanges (List[Range]): The ranges at which the calls appear.\n    \"\"\"\n\n    from_: CallHierarchyItem\n    fromRanges: t.List[Range]\n\n    class Config:\n        # 'from' is an invalid field - re-mapping\n        fields = {\"from_\": \"from\"}\n</code></pre>"},{"location":"api/structs/#tarts.structs.CallHierarchyItem","title":"<code>CallHierarchyItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an item of a call hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of this item.</p> required <code>kind</code> <code>SymbolKind</code> <p>The kind of this item.</p> required <code>tags</code> <code>Optional[SymbolTag]</code> <p>Tags for this item.</p> required <code>detail</code> <code>Optional[str]</code> <p>More detail for this item.</p> required <code>uri</code> <code>str</code> <p>The resource identifier of this item.</p> required <code>range</code> <code>Range</code> <p>The range enclosing this symbol.</p> required <code>selectionRange</code> <code>Range</code> <p>The range that should be selected and revealed when this symbol is being picked.</p> required <code>data</code> <code>Optional[Any]</code> <p>A data entry field that is preserved between a call hierarchy prepare and incoming calls or outgoing calls requests.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class CallHierarchyItem(BaseModel):\n    \"\"\"Represents an item of a call hierarchy.\n\n    Args:\n        name (str): The name of this item.\n        kind (SymbolKind): The kind of this item.\n        tags (Optional[SymbolTag]): Tags for this item.\n        detail (Optional[str]): More detail for this item.\n        uri (str): The resource identifier of this item.\n        range (Range): The range enclosing this symbol.\n        selectionRange (Range): The range that should be selected and revealed when this symbol is being picked.\n        data (Optional[Any]): A data entry field that is preserved between a call hierarchy prepare and incoming calls or outgoing calls requests.\n    \"\"\"\n\n    name: str\n    kind: SymbolKind\n    tags: t.Optional[SymbolTag]\n    detail: t.Optional[str]\n    uri: str\n    range: Range\n    selectionRange: Range\n    data: t.Optional[t.Any]\n</code></pre>"},{"location":"api/structs/#tarts.structs.CallHierarchyOutgoingCall","title":"<code>CallHierarchyOutgoingCall</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an outgoing call, as part of the call hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>to</code> <code>CallHierarchyItem</code> <p>The item that is called.</p> required <code>fromRanges</code> <code>List[Range]</code> <p>The ranges at which this item is called.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class CallHierarchyOutgoingCall(BaseModel):\n    \"\"\"Represents an outgoing call, as part of the call hierarchy.\n\n    Args:\n        to (CallHierarchyItem): The item that is called.\n        fromRanges (List[Range]): The ranges at which this item is called.\n    \"\"\"\n\n    to: CallHierarchyItem\n    fromRanges: t.List[Range]\n</code></pre>"},{"location":"api/structs/#tarts.structs.CodeDescription","title":"<code>CodeDescription</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a code description.</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>The URI to the code description.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class CodeDescription(BaseModel):\n    \"\"\"Represents a code description.\n\n    Args:\n        href (str): The URI to the code description.\n    \"\"\"\n\n    href: str\n</code></pre>"},{"location":"api/structs/#tarts.structs.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a reference to a command.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the command, like <code>save</code>.</p> required <code>command</code> <code>str</code> <p>The identifier of the actual command handler.</p> required <code>arguments</code> <code>Optional[List[Any]]</code> <p>Arguments that the command handler should be invoked with.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class Command(BaseModel):\n    \"\"\"Represents a reference to a command.\n\n    Args:\n        title (str): Title of the command, like `save`.\n        command (str): The identifier of the actual command handler.\n        arguments (Optional[List[Any]]): Arguments that the command handler should be invoked with.\n    \"\"\"\n\n    title: str\n    command: str\n    arguments: t.Optional[t.List[t.Any]]\n</code></pre>"},{"location":"api/structs/#tarts.structs.CompletionContext","title":"<code>CompletionContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains additional information about the context in which a completion request is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>triggerKind</code> <code>CompletionTriggerKind</code> <p>How the completion was triggered.</p> required <code>triggerCharacter</code> <code>Optional[str]</code> <p>The trigger character that caused the completion.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class CompletionContext(BaseModel):\n    \"\"\"Contains additional information about the context in which a completion request is triggered.\n\n    Args:\n        triggerKind (CompletionTriggerKind): How the completion was triggered.\n        triggerCharacter (Optional[str]): The trigger character that caused the completion.\n    \"\"\"\n\n    triggerKind: CompletionTriggerKind\n    triggerCharacter: t.Optional[str]\n</code></pre>"},{"location":"api/structs/#tarts.structs.CompletionItem","title":"<code>CompletionItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A completion item represents a text snippet that is proposed to complete text that is being typed.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of this completion item.</p> required <code>kind</code> <code>Optional[CompletionItemKind]</code> <p>The kind of this completion item.</p> required <code>tags</code> <code>Optional[CompletionItemTag]</code> <p>Tags for this completion item.</p> required <code>detail</code> <code>Optional[str]</code> <p>A human-readable string with additional information about this item.</p> required <code>documentation</code> <code>Union[str, MarkupContent, None]</code> <p>A human-readable string that represents a doc-comment.</p> required <code>deprecated</code> <code>Optional[bool]</code> <p>Indicates if this item is deprecated.</p> required <code>preselect</code> <code>Optional[bool]</code> <p>Select this item when showing.</p> required <code>sortText</code> <code>Optional[str]</code> <p>A string that should be used when comparing this item with other items.</p> required <code>filterText</code> <code>Optional[str]</code> <p>A string that should be used when filtering a set of completion items.</p> required <code>insertText</code> <code>Optional[str]</code> <p>A string that should be inserted into a document when selecting this completion.</p> required <code>insertTextFormat</code> <code>Optional[InsertTextFormat]</code> <p>The format of the insert text.</p> required <code>textEdit</code> <code>Optional[TextEdit]</code> <p>An edit which is applied to a document when selecting this completion.</p> required <code>additionalTextEdits</code> <code>Optional[List[TextEdit]]</code> <p>An optional array of additional text edits that are applied when selecting this completion.</p> required <code>commitCharacters</code> <code>Optional[List[str]]</code> <p>An optional set of characters that when pressed while this completion is active will accept it first and then type that character.</p> required <code>command</code> <code>Optional[Command]</code> <p>An optional command that is executed after inserting this completion.</p> required <code>data</code> <code>Optional[Any]</code> <p>A data entry field that is preserved on a completion item between a completion and a completion resolve request.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class CompletionItem(BaseModel):\n    \"\"\"A completion item represents a text snippet that is proposed to complete text that is being typed.\n\n    Args:\n        label (str): The label of this completion item.\n        kind (Optional[CompletionItemKind]): The kind of this completion item.\n        tags (Optional[CompletionItemTag]): Tags for this completion item.\n        detail (Optional[str]): A human-readable string with additional information about this item.\n        documentation (Union[str, MarkupContent, None]): A human-readable string that represents a doc-comment.\n        deprecated (Optional[bool]): Indicates if this item is deprecated.\n        preselect (Optional[bool]): Select this item when showing.\n        sortText (Optional[str]): A string that should be used when comparing this item with other items.\n        filterText (Optional[str]): A string that should be used when filtering a set of completion items.\n        insertText (Optional[str]): A string that should be inserted into a document when selecting this completion.\n        insertTextFormat (Optional[InsertTextFormat]): The format of the insert text.\n        textEdit (Optional[TextEdit]): An edit which is applied to a document when selecting this completion.\n        additionalTextEdits (Optional[List[TextEdit]]): An optional array of additional text edits that are applied when selecting this completion.\n        commitCharacters (Optional[List[str]]): An optional set of characters that when pressed while this completion is active will accept it first and then type that character.\n        command (Optional[Command]): An optional command that is executed after inserting this completion.\n        data (Optional[Any]): A data entry field that is preserved on a completion item between a completion and a completion resolve request.\n    \"\"\"\n\n    label: str\n    kind: t.Optional[CompletionItemKind]\n    tags: t.Optional[CompletionItemTag]\n    detail: t.Optional[str]\n    documentation: t.Union[str, MarkupContent, None]\n    deprecated: t.Optional[bool]\n    preselect: t.Optional[bool]\n    sortText: t.Optional[str]\n    filterText: t.Optional[str]\n    insertText: t.Optional[str]\n    insertTextFormat: t.Optional[InsertTextFormat]\n    textEdit: t.Optional[TextEdit]\n    additionalTextEdits: t.Optional[t.List[TextEdit]]\n    commitCharacters: t.Optional[t.List[str]]\n    command: t.Optional[Command]\n    data: t.Optional[t.Any]\n</code></pre>"},{"location":"api/structs/#tarts.structs.CompletionItemKind","title":"<code>CompletionItemKind</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>The kind of a completion entry.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class CompletionItemKind(enum.IntEnum):\n    \"\"\"The kind of a completion entry.\n\n    Attributes:\n        Various completion item kinds with integer values from 1 to 25.\n    \"\"\"\n\n    TEXT = 1\n    METHOD = 2\n    FUNCTION = 3\n    CONSTRUCTOR = 4\n    FIELD = 5\n    VARIABLE = 6\n    CLASS = 7\n    INTERFACE = 8\n    MODULE = 9\n    PROPERTY = 10\n    UNIT = 11\n    VALUE = 12\n    ENUM = 13\n    KEYWORD = 14\n    SNIPPET = 15\n    COLOR = 16\n    FILE = 17\n    REFERENCE = 18\n    FOLDER = 19\n    ENUMMEMBER = 20\n    CONSTANT = 21\n    STRUCT = 22\n    EVENT = 23\n    OPERATOR = 24\n    TYPEPARAMETER = 25\n</code></pre>"},{"location":"api/structs/#tarts.structs.CompletionItemTag","title":"<code>CompletionItemTag</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Completion item tags are extra annotations that tweak the rendering of a completion item.</p> <p>Attributes:</p> Name Type Description <code>DEPRECATED</code> <p>Renders a completion as obsolete, usually using a strike-out.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class CompletionItemTag(enum.IntEnum):\n    \"\"\"Completion item tags are extra annotations that tweak the rendering of a completion item.\n\n    Attributes:\n        DEPRECATED: Renders a completion as obsolete, usually using a strike-out.\n    \"\"\"\n\n    DEPRECATED = 1\n</code></pre>"},{"location":"api/structs/#tarts.structs.CompletionList","title":"<code>CompletionList</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a collection of completion items to be presented in the editor.</p> <p>Parameters:</p> Name Type Description Default <code>isIncomplete</code> <code>bool</code> <p>This list is not complete. Further typing should result in recomputing this list.</p> required <code>items</code> <code>List[CompletionItem]</code> <p>The completion items.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class CompletionList(BaseModel):\n    \"\"\"Represents a collection of completion items to be presented in the editor.\n\n    Args:\n        isIncomplete (bool): This list is not complete. Further typing should result in recomputing this list.\n        items (List[CompletionItem]): The completion items.\n    \"\"\"\n\n    isIncomplete: bool\n    items: t.List[CompletionItem]\n</code></pre>"},{"location":"api/structs/#tarts.structs.CompletionTriggerKind","title":"<code>CompletionTriggerKind</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Defines how the completion was triggered.</p> <p>Attributes:</p> Name Type Description <code>INVOKED</code> <p>Completion was triggered by typing an identifier.</p> <code>TRIGGER_CHARACTER</code> <p>Completion was triggered by a trigger character.</p> <code>TRIGGER_FOR_INCOMPLETE_COMPLETIONS</code> <p>Completion was re-triggered as the current completion list is incomplete.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class CompletionTriggerKind(enum.IntEnum):\n    \"\"\"Defines how the completion was triggered.\n\n    Attributes:\n        INVOKED: Completion was triggered by typing an identifier.\n        TRIGGER_CHARACTER: Completion was triggered by a trigger character.\n        TRIGGER_FOR_INCOMPLETE_COMPLETIONS: Completion was re-triggered as the current completion list is incomplete.\n    \"\"\"\n\n    INVOKED = 1\n    TRIGGER_CHARACTER = 2\n    TRIGGER_FOR_INCOMPLETE_COMPLETIONS = 3\n</code></pre>"},{"location":"api/structs/#tarts.structs.ConfigurationItem","title":"<code>ConfigurationItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a configuration item.</p> <p>Parameters:</p> Name Type Description Default <code>scopeUri</code> <code>Optional[str]</code> <p>The scope URI for this configuration item.</p> required <code>section</code> <code>Optional[str]</code> <p>The section of the configuration this item belongs to.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class ConfigurationItem(BaseModel):\n    \"\"\"Represents a configuration item.\n\n    Args:\n        scopeUri (Optional[str]): The scope URI for this configuration item.\n        section (Optional[str]): The section of the configuration this item belongs to.\n    \"\"\"\n\n    scopeUri: t.Optional[str]\n    section: t.Optional[str]\n</code></pre>"},{"location":"api/structs/#tarts.structs.Diagnostic","title":"<code>Diagnostic</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a diagnostic, such as a compiler error or warning.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>Range</code> <p>The range at which the message applies.</p> required <code>severity</code> <code>Optional[DiagnosticSeverity]</code> <p>The diagnostic's severity.</p> required <code>code</code> <code>Optional[Union[int, str]]</code> <p>The diagnostic's code, which might appear in the user interface.</p> required <code>codeDescription</code> <code>Optional[CodeDescription]</code> <p>An optional code description.</p> required <code>source</code> <code>Optional[str]</code> <p>A human-readable string describing the source of this diagnostic.</p> required <code>message</code> <code>str</code> <p>The diagnostic's message.</p> required <code>tags</code> <code>Optional[List[DiagnosticTag]]</code> <p>Additional metadata about the diagnostic.</p> required <code>relatedInformation</code> <code>Optional[List[DiagnosticRelatedInformation]]</code> <p>Related diagnostic information.</p> required <code>data</code> <code>Optional[Any]</code> <p>Additional structured data about the diagnostic.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class Diagnostic(BaseModel):\n    \"\"\"Represents a diagnostic, such as a compiler error or warning.\n\n    Args:\n        range (Range): The range at which the message applies.\n        severity (Optional[DiagnosticSeverity]): The diagnostic's severity.\n        code (Optional[Union[int, str]]): The diagnostic's code, which might appear in the user interface.\n        codeDescription (Optional[CodeDescription]): An optional code description.\n        source (Optional[str]): A human-readable string describing the source of this diagnostic.\n        message (str): The diagnostic's message.\n        tags (Optional[List[DiagnosticTag]]): Additional metadata about the diagnostic.\n        relatedInformation (Optional[List[DiagnosticRelatedInformation]]): Related diagnostic information.\n        data (Optional[Any]): Additional structured data about the diagnostic.\n    \"\"\"\n\n    range: Range\n    severity: t.Optional[DiagnosticSeverity]\n    code: t.Optional[t.Union[int, str]]\n    codeDescription: t.Optional[CodeDescription]\n    source: t.Optional[str]\n    message: str\n    tags: t.Optional[t.List[DiagnosticTag]]\n    relatedInformation: t.Optional[t.List[DiagnosticRelatedInformation]]\n    data: t.Optional[t.Any]\n</code></pre>"},{"location":"api/structs/#tarts.structs.DiagnosticRelatedInformation","title":"<code>DiagnosticRelatedInformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents additional information related to a diagnostic.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>The location of this related diagnostic information.</p> required <code>message</code> <code>str</code> <p>The message of this related diagnostic information.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class DiagnosticRelatedInformation(BaseModel):\n    \"\"\"Represents additional information related to a diagnostic.\n\n    Args:\n        location (Location): The location of this related diagnostic information.\n        message (str): The message of this related diagnostic information.\n    \"\"\"\n\n    location: Location\n    message: str\n</code></pre>"},{"location":"api/structs/#tarts.structs.DiagnosticSeverity","title":"<code>DiagnosticSeverity</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of diagnostic severity levels.</p> <p>Attributes:</p> Name Type Description <code>ERROR</code> <code>int</code> <p>Error severity level.</p> <code>WARNING</code> <code>int</code> <p>Warning severity level.</p> <code>INFORMATION</code> <code>int</code> <p>Information severity level.</p> <code>HINT</code> <code>int</code> <p>Hint severity level.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class DiagnosticSeverity(enum.IntEnum):\n    \"\"\"Enumeration of diagnostic severity levels.\n\n    Attributes:\n        ERROR (int): Error severity level.\n        WARNING (int): Warning severity level.\n        INFORMATION (int): Information severity level.\n        HINT (int): Hint severity level.\n    \"\"\"\n\n    ERROR = 1\n    WARNING = 2\n    INFORMATION = 3\n    HINT = 4\n</code></pre>"},{"location":"api/structs/#tarts.structs.DiagnosticTag","title":"<code>DiagnosticTag</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of diagnostic tags.</p> <p>Attributes:</p> Name Type Description <code>UNNECESSARY</code> <code>int</code> <p>Unnecessary code.</p> <code>DEPRECATED</code> <code>int</code> <p>Deprecated code.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class DiagnosticTag(enum.IntEnum):\n    \"\"\"Enumeration of diagnostic tags.\n\n    Attributes:\n        UNNECESSARY (int): Unnecessary code.\n        DEPRECATED (int): Deprecated code.\n    \"\"\"\n\n    UNNECESSARY = 1\n    DEPRECATED = 2\n</code></pre>"},{"location":"api/structs/#tarts.structs.DocumentSymbol","title":"<code>DocumentSymbol</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents programming constructs like variables, classes, interfaces etc. that appear in a document.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of this symbol.</p> required <code>detail</code> <code>Optional[str]</code> <p>More detail for this symbol, e.g. the signature of a function.</p> required <code>kind</code> <code>SymbolKind</code> <p>The kind of this symbol.</p> required <code>tags</code> <code>Optional[List[SymbolTag]]</code> <p>Tags for this symbol.</p> required <code>deprecated</code> <code>Optional[bool]</code> <p>Indicates if this symbol is deprecated.</p> required <code>range</code> <code>Range</code> <p>The range enclosing this symbol not including leading/trailing whitespace but everything else.</p> required <code>selectionRange</code> <code>Range</code> <p>The range that should be selected and revealed when this symbol is being picked.</p> required <code>children</code> <code>Optional[List[DocumentSymbol]]</code> <p>Children of this symbol, e.g. properties of a class.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class DocumentSymbol(BaseModel):\n    \"\"\"Represents programming constructs like variables, classes, interfaces etc. that appear in a document.\n\n    Args:\n        name (str): The name of this symbol.\n        detail (Optional[str]): More detail for this symbol, e.g. the signature of a function.\n        kind (SymbolKind): The kind of this symbol.\n        tags (Optional[List[SymbolTag]]): Tags for this symbol.\n        deprecated (Optional[bool]): Indicates if this symbol is deprecated.\n        range (Range): The range enclosing this symbol not including leading/trailing whitespace but everything else.\n        selectionRange (Range): The range that should be selected and revealed when this symbol is being picked.\n        children (Optional[List[DocumentSymbol]]): Children of this symbol, e.g. properties of a class.\n    \"\"\"\n\n    name: str\n    detail: t.Optional[str]\n    kind: SymbolKind\n    tags: t.Optional[t.List[SymbolTag]]\n    deprecated: t.Optional[bool]\n    range: Range\n    selectionRange: Range\n    children: t.Optional[t.List[\"DocumentSymbol\"]]\n</code></pre>"},{"location":"api/structs/#tarts.structs.FoldingRange","title":"<code>FoldingRange</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a folding range.</p> <p>Parameters:</p> Name Type Description Default <code>startLine</code> <code>int</code> <p>The zero-based start line of the range to fold.</p> required <code>startCharacter</code> <code>Optional[int]</code> <p>The zero-based start character of the range to fold.</p> required <code>endLine</code> <code>int</code> <p>The zero-based end line of the range to fold.</p> required <code>endCharacter</code> <code>Optional[int]</code> <p>The zero-based end character of the range to fold.</p> required <code>kind</code> <code>Optional[str]</code> <p>The kind of this folding range (e.g., 'comment', 'imports', 'region').</p> required <code>collapsedText</code> <code>Optional[str]</code> <p>The text that the client should show when the specified range is collapsed.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class FoldingRange(BaseModel):\n    \"\"\"Represents a folding range.\n\n    Args:\n        startLine (int): The zero-based start line of the range to fold.\n        startCharacter (Optional[int]): The zero-based start character of the range to fold.\n        endLine (int): The zero-based end line of the range to fold.\n        endCharacter (Optional[int]): The zero-based end character of the range to fold.\n        kind (Optional[str]): The kind of this folding range (e.g., 'comment', 'imports', 'region').\n        collapsedText (Optional[str]): The text that the client should show when the specified range is collapsed.\n    \"\"\"\n\n    startLine: int\n    startCharacter: t.Optional[int]\n    endLine: int\n    endCharacter: t.Optional[int]\n    kind: t.Optional[str]  # comment, imports, region\n    collapsedText: t.Optional[str]\n</code></pre>"},{"location":"api/structs/#tarts.structs.FormattingOptions","title":"<code>FormattingOptions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents formatting options.</p> <p>Parameters:</p> Name Type Description Default <code>tabSize</code> <code>int</code> <p>Size of a tab in spaces.</p> required <code>insertSpaces</code> <code>bool</code> <p>Prefer spaces over tabs.</p> required <code>trimTrailingWhitespace</code> <code>Optional[bool]</code> <p>Trim trailing whitespace on a line.</p> required <code>insertFinalNewline</code> <code>Optional[bool]</code> <p>Insert a newline character at the end of the file if one does not exist.</p> required <code>trimFinalNewlines</code> <code>Optional[bool]</code> <p>Trim all newlines after the final newline at the end of the file.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class FormattingOptions(BaseModel):\n    \"\"\"Represents formatting options.\n\n    Args:\n        tabSize (int): Size of a tab in spaces.\n        insertSpaces (bool): Prefer spaces over tabs.\n        trimTrailingWhitespace (Optional[bool]): Trim trailing whitespace on a line.\n        insertFinalNewline (Optional[bool]): Insert a newline character at the end of the file if one does not exist.\n        trimFinalNewlines (Optional[bool]): Trim all newlines after the final newline at the end of the file.\n    \"\"\"\n\n    tabSize: int\n    insertSpaces: bool\n    trimTrailingWhitespace: t.Optional[bool]\n    insertFinalNewline: t.Optional[bool]\n    trimFinalNewlines: t.Optional[bool]\n</code></pre>"},{"location":"api/structs/#tarts.structs.InlayHint","title":"<code>InlayHint</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an inlay hint.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Position</code> <p>The position of this hint.</p> required <code>label</code> <code>Union[str, List[InlayHintLabelPart]]</code> <p>The label of this hint.</p> required <code>kind</code> <code>Optional[InlayHintKind]</code> <p>The kind of this hint.</p> required <code>textEdits</code> <code>Optional[List[TextEdit]]</code> <p>Optional text edits that are performed when accepting this inlay hint.</p> required <code>tooltip</code> <code>Optional[Union[str, MarkupContent]]</code> <p>The tooltip text when you hover over this item.</p> required <code>paddingLeft</code> <code>Optional[bool]</code> <p>Whether the inlay hint should be padded with a space on the left.</p> required <code>paddingRight</code> <code>Optional[bool]</code> <p>Whether the inlay hint should be padded with a space on the right.</p> required <code>data</code> <code>Optional[Any]</code> <p>A data entry field that is preserved on an inlay hint between a textDocument/inlayHint request and a inlayHint/resolve request.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class InlayHint(BaseModel):\n    \"\"\"Represents an inlay hint.\n\n    Args:\n        position (Position): The position of this hint.\n        label (Union[str, List[InlayHintLabelPart]]): The label of this hint.\n        kind (Optional[InlayHintKind]): The kind of this hint.\n        textEdits (Optional[List[TextEdit]]): Optional text edits that are performed when accepting this inlay hint.\n        tooltip (Optional[Union[str, MarkupContent]]): The tooltip text when you hover over this item.\n        paddingLeft (Optional[bool]): Whether the inlay hint should be padded with a space on the left.\n        paddingRight (Optional[bool]): Whether the inlay hint should be padded with a space on the right.\n        data (Optional[Any]): A data entry field that is preserved on an inlay hint between a textDocument/inlayHint request and a inlayHint/resolve request.\n    \"\"\"\n\n    position: Position\n    label: t.Union[str, t.List[InlayHintLabelPart]]\n    kind: t.Optional[InlayHintKind]\n    textEdits: t.Optional[t.List[TextEdit]]\n    tooltip: t.Optional[t.Union[str, MarkupContent]]\n    paddingLeft: t.Optional[bool]\n    paddingRight: t.Optional[bool]\n    data: t.Optional[t.Any]\n</code></pre>"},{"location":"api/structs/#tarts.structs.InlayHintKind","title":"<code>InlayHintKind</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of inlay hint kinds.</p> <p>Attributes:</p> Name Type Description <code>TYPE</code> <code>int</code> <p>Type hint.</p> <code>PARAMETER</code> <code>int</code> <p>Parameter hint.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class InlayHintKind(enum.IntEnum):\n    \"\"\"Enumeration of inlay hint kinds.\n\n    Attributes:\n        TYPE (int): Type hint.\n        PARAMETER (int): Parameter hint.\n    \"\"\"\n\n    TYPE = 1\n    PARAMETER = 2\n</code></pre>"},{"location":"api/structs/#tarts.structs.InlayHintLabelPart","title":"<code>InlayHintLabelPart</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a part of an inlay hint.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The value of this label part.</p> required <code>tooltip</code> <code>Optional[Union[str, MarkupContent]]</code> <p>The tooltip text when you hover over this label part.</p> required <code>location</code> <code>Optional[Location]</code> <p>An optional source code location that represents this label part.</p> required <code>command</code> <code>Optional[Command]</code> <p>An optional command for this label part.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class InlayHintLabelPart(BaseModel):\n    \"\"\"Represents a part of an inlay hint.\n\n    Args:\n        value (str): The value of this label part.\n        tooltip (Optional[Union[str, MarkupContent]]): The tooltip text when you hover over this label part.\n        location (Optional[Location]): An optional source code location that represents this label part.\n        command (Optional[Command]): An optional command for this label part.\n    \"\"\"\n\n    value: str\n    tooltip: t.Optional[t.Union[str, MarkupContent]]\n    location: t.Optional[Location]\n    command: t.Optional[Command]\n</code></pre>"},{"location":"api/structs/#tarts.structs.InsertTextFormat","title":"<code>InsertTextFormat</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Defines whether the insert text in a completion item should be interpreted as plain text or a snippet.</p> <p>Attributes:</p> Name Type Description <code>PLAIN_TEXT</code> <p>The primary text should be interpreted as plain text.</p> <code>SNIPPET</code> <p>The primary text should be interpreted as a snippet.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class InsertTextFormat(enum.IntEnum):\n    \"\"\"Defines whether the insert text in a completion item should be interpreted as plain text or a snippet.\n\n    Attributes:\n        PLAIN_TEXT: The primary text should be interpreted as plain text.\n        SNIPPET: The primary text should be interpreted as a snippet.\n    \"\"\"\n\n    PLAIN_TEXT = 1\n    SNIPPET = 2\n</code></pre>"},{"location":"api/structs/#tarts.structs.Location","title":"<code>Location</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a location inside a resource, such as a line inside a text file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The text document's URI.</p> required <code>range</code> <code>Range</code> <p>The range inside the text document.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class Location(BaseModel):\n    \"\"\"Represents a location inside a resource, such as a line inside a text file.\n\n    Args:\n        uri (str): The text document's URI.\n        range (Range): The range inside the text document.\n    \"\"\"\n\n    uri: str\n    range: Range\n</code></pre>"},{"location":"api/structs/#tarts.structs.LocationLink","title":"<code>LocationLink</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a link between a source and a target location.</p> <p>Parameters:</p> Name Type Description Default <code>originSelectionRange</code> <code>Optional[Range]</code> <p>Span of the origin of this link.</p> required <code>targetUri</code> <code>str</code> <p>The target resource identifier of this link.</p> required <code>targetRange</code> <code>Range</code> <p>The full target range of this link.</p> required <code>targetSelectionRange</code> <code>Range</code> <p>The span of the target of this link.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class LocationLink(BaseModel):\n    \"\"\"Represents a link between a source and a target location.\n\n    Args:\n        originSelectionRange (Optional[Range]): Span of the origin of this link.\n        targetUri (str): The target resource identifier of this link.\n        targetRange (Range): The full target range of this link.\n        targetSelectionRange (Range): The span of the target of this link.\n    \"\"\"\n\n    originSelectionRange: t.Optional[Range]\n    targetUri: str  # in the spec the type is DocumentUri\n    targetRange: Range\n    targetSelectionRange: Range\n</code></pre>"},{"location":"api/structs/#tarts.structs.MWorkDoneProgressKind","title":"<code>MWorkDoneProgressKind</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of work done progress kinds.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class MWorkDoneProgressKind(enum.Enum):\n    \"\"\"Enumeration of work done progress kinds.\"\"\"\n\n    BEGIN = \"begin\"\n    REPORT = \"report\"\n    END = \"end\"\n</code></pre>"},{"location":"api/structs/#tarts.structs.MarkedString","title":"<code>MarkedString</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a string with a specific language.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>The language of the string (e.g., 'python', 'javascript').</p> required <code>value</code> <code>str</code> <p>The string value.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class MarkedString(BaseModel):\n    \"\"\"Represents a string with a specific language.\n\n    Args:\n        language (str): The language of the string (e.g., 'python', 'javascript').\n        value (str): The string value.\n    \"\"\"\n\n    language: str\n    value: str\n</code></pre>"},{"location":"api/structs/#tarts.structs.MarkupContent","title":"<code>MarkupContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a string value which content can be represented in different formats.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>MarkupKind</code> <p>The type of markup used.</p> required <code>value</code> <code>str</code> <p>The content itself.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class MarkupContent(BaseModel):\n    \"\"\"Represents a string value which content can be represented in different formats.\n\n    Args:\n        kind (MarkupKind): The type of markup used.\n        value (str): The content itself.\n    \"\"\"\n\n    kind: MarkupKind\n    value: str\n</code></pre>"},{"location":"api/structs/#tarts.structs.MarkupKind","title":"<code>MarkupKind</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Describes the content type that a client supports in various result literals like <code>Hover</code>, <code>ParameterInfo</code> or <code>CompletionItem</code>.</p> <p>Attributes:</p> Name Type Description <code>PLAINTEXT</code> <p>The primary text to be rendered is to be interpreted as plain text.</p> <code>MARKDOWN</code> <p>The primary text to be rendered is to be interpreted as Markdown.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class MarkupKind(enum.Enum):\n    \"\"\"Describes the content type that a client supports in various result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n\n    Attributes:\n        PLAINTEXT: The primary text to be rendered is to be interpreted as plain text.\n        MARKDOWN: The primary text to be rendered is to be interpreted as Markdown.\n    \"\"\"\n\n    PLAINTEXT = \"plaintext\"\n    MARKDOWN = \"markdown\"\n</code></pre>"},{"location":"api/structs/#tarts.structs.MessageActionItem","title":"<code>MessageActionItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Action item for LSP notifications.</p> <p>Parameters:</p> Name Type Description Default <code>title(str)</code> <p>The title of the action.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class MessageActionItem(BaseModel):\n    \"\"\"Action item for LSP notifications.\n\n    Args:\n        title(str): The title of the action.\n    \"\"\"\n\n    title: str\n</code></pre>"},{"location":"api/structs/#tarts.structs.MessageType","title":"<code>MessageType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Message type for LSP notifications.</p> <p>Attributes:</p> Name Type Description <code>ERROR</code> <code>int</code> <p>Error message.</p> <code>WARNING</code> <code>int</code> <p>Warning message.</p> <code>INFO</code> <code>int</code> <p>Information message.</p> <code>LOG</code> <code>int</code> <p>Log message.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class MessageType(enum.IntEnum):\n    \"\"\"Message type for LSP notifications.\n\n    Attributes:\n        ERROR: Error message.\n        WARNING: Warning message.\n        INFO: Information message.\n        LOG: Log message.\n    \"\"\"\n\n    ERROR: int = 1\n    WARNING: int = 2\n    INFO: int = 3\n    LOG: int = 4\n</code></pre>"},{"location":"api/structs/#tarts.structs.OptionalVersionedTextDocumentIdentifier","title":"<code>OptionalVersionedTextDocumentIdentifier</code>","text":"<p>               Bases: <code>TextDocumentIdentifier</code></p> <p>Text document identifier with an optional version for LSP requests.</p> <p>Parameters:</p> Name Type Description Default <code>uri(str)</code> <p>The URI of the document</p> required <code>version(int)</code> <p>The version of the document</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class OptionalVersionedTextDocumentIdentifier(TextDocumentIdentifier):\n    \"\"\"Text document identifier with an optional version for LSP requests.\n\n    Args:\n        uri(str): The URI of the document\n        version(int): The version of the document\n    \"\"\"\n\n    version: t.Optional[int]\n</code></pre>"},{"location":"api/structs/#tarts.structs.ParameterInformation","title":"<code>ParameterInformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents information about a parameter of a callable-signature.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Union[str, Tuple[int, int]]</code> <p>The label of this parameter information.</p> required <code>documentation</code> <code>Optional[Union[str, MarkupContent]]</code> <p>The human-readable doc-comment of this parameter.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class ParameterInformation(BaseModel):\n    \"\"\"Represents information about a parameter of a callable-signature.\n\n    Args:\n        label (Union[str, Tuple[int, int]]): The label of this parameter information.\n        documentation (Optional[Union[str, MarkupContent]]): The human-readable doc-comment of this parameter.\n    \"\"\"\n\n    label: t.Union[str, t.Tuple[int, int]]\n    documentation: t.Optional[t.Union[str, MarkupContent]]\n</code></pre>"},{"location":"api/structs/#tarts.structs.Position","title":"<code>Position</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Position in a text document.</p> <p>Methods:</p> Name Description <code>as_tuple</code> <p>Return the position as a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line number (0-based).</p> required <code>character</code> <code>int</code> <p>The character number (0-based).</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class Position(BaseModel):\n    \"\"\"Position in a text document.\n\n    Methods:\n        as_tuple: Return the position as a tuple.\n\n    Args:\n        line (int): The line number (0-based).\n        character (int): The character number (0-based).\n    \"\"\"\n\n    # NB: These are both zero-based.\n    line: int\n    character: int\n\n    def as_tuple(self) -&gt; t.Tuple[int, int]:\n        \"\"\"Return the position as a tuple.\n\n        Returns:\n            Tuple[int, int]: The position as a tuple.\n        \"\"\"\n\n        return (self.line, self.character)\n</code></pre>"},{"location":"api/structs/#tarts.structs.Position.as_tuple","title":"<code>as_tuple()</code>","text":"<p>Return the position as a tuple.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple[int, int]: The position as a tuple.</p> Source code in <code>tarts\\structs.py</code> <pre><code>def as_tuple(self) -&gt; t.Tuple[int, int]:\n    \"\"\"Return the position as a tuple.\n\n    Returns:\n        Tuple[int, int]: The position as a tuple.\n    \"\"\"\n\n    return (self.line, self.character)\n</code></pre>"},{"location":"api/structs/#tarts.structs.ProgressValue","title":"<code>ProgressValue</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for progress values.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class ProgressValue(BaseModel):\n    \"\"\"Base class for progress values.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/structs/#tarts.structs.Range","title":"<code>Range</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a range in a text document.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Position</code> <p>The start position of the range.</p> required <code>end</code> <code>Position</code> <p>The end position of the range.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class Range(BaseModel):\n    \"\"\"Represents a range in a text document.\n\n    Args:\n        start (Position): The start position of the range.\n        end (Position): The end position of the range.\n    \"\"\"\n\n    start: Position\n    end: Position\n\n    def calculate_length(self, text: str) -&gt; int:\n        \"\"\"Calculate the length of the range in the given text.\n\n        Args:\n            text (str): The text to calculate the range length in.\n\n        Returns:\n            int: The length of the range.\n        \"\"\"\n        text_lines = text.splitlines()\n\n        if self.end.line == self.start.line:\n            line = text_lines[self.start.line]\n            return len(line[self.start.character : self.end.character])\n        else:\n            total = 0\n\n            total += len(text_lines[self.start.line][self.start.character :])\n\n            for line_number in range(self.start.line + 1, self.end.line):\n                total += len(text_lines[line_number])\n\n            total += len(text_lines[self.end.line][: self.end.character])\n\n            return total\n</code></pre>"},{"location":"api/structs/#tarts.structs.Range.calculate_length","title":"<code>calculate_length(text)</code>","text":"<p>Calculate the length of the range in the given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to calculate the range length in.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the range.</p> Source code in <code>tarts\\structs.py</code> <pre><code>def calculate_length(self, text: str) -&gt; int:\n    \"\"\"Calculate the length of the range in the given text.\n\n    Args:\n        text (str): The text to calculate the range length in.\n\n    Returns:\n        int: The length of the range.\n    \"\"\"\n    text_lines = text.splitlines()\n\n    if self.end.line == self.start.line:\n        line = text_lines[self.start.line]\n        return len(line[self.start.character : self.end.character])\n    else:\n        total = 0\n\n        total += len(text_lines[self.start.line][self.start.character :])\n\n        for line_number in range(self.start.line + 1, self.end.line):\n            total += len(text_lines[line_number])\n\n        total += len(text_lines[self.end.line][: self.end.character])\n\n        return total\n</code></pre>"},{"location":"api/structs/#tarts.structs.Registration","title":"<code>Registration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a registration of a capability.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id used to register the request. The id can be used to deregister the request again.</p> required <code>method</code> <code>str</code> <p>The method / capability to register for.</p> required <code>registerOptions</code> <code>Optional[Any]</code> <p>Options necessary for the registration.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class Registration(BaseModel):\n    \"\"\"Represents a registration of a capability.\n\n    Args:\n        id (str): The id used to register the request. The id can be used to deregister the request again.\n        method (str): The method / capability to register for.\n        registerOptions (Optional[Any]): Options necessary for the registration.\n    \"\"\"\n\n    id: str\n    method: str\n    registerOptions: t.Optional[t.Any]\n</code></pre>"},{"location":"api/structs/#tarts.structs.Request","title":"<code>Request</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for LSP requests.</p> <p>Parameters:</p> Name Type Description Default <code>method(str)</code> <p>The method of the request.</p> required <code>id</code> <code>Id</code> <p>The request ID.</p> required <code>params</code> <code>JSONDict</code> <p>The parameters of the request.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class Request(BaseModel):\n    \"\"\"Base class for LSP requests.\n\n    Args:\n        method(str): The method of the request.\n        id (Id): The request ID.\n        params (JSONDict): The parameters of the request.\n    \"\"\"\n\n    method: str\n    id: t.Optional[Id]\n    params: t.Optional[JSONDict]\n</code></pre>"},{"location":"api/structs/#tarts.structs.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for LSP responses.</p> <p>The <code>result</code> field is either a list of values or a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Id</code> <p>The request ID.</p> required <code>result(List[Any]</code> <code>| JSONDict</code> <p>The result of the request.</p> required <code>error</code> <p>The error that occurred during the request.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"Base class for LSP responses.\n\n    The `result` field is either a list of values or a dictionary.\n\n    Args:\n        id (Id): The request ID.\n        result(List[Any] | JSONDict): The result of the request.\n        error: The error that occurred during the request.\n    \"\"\"\n\n    id: t.Optional[Id]\n    result: t.Optional[t.Union[t.List[t.Any], JSONDict]]\n    error: t.Optional[JSONDict]\n</code></pre>"},{"location":"api/structs/#tarts.structs.SignatureInformation","title":"<code>SignatureInformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the signature of something callable.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of this signature.</p> required <code>documentation</code> <code>Optional[Union[MarkupContent, str]]</code> <p>The human-readable doc-comment of this signature.</p> required <code>parameters</code> <code>Optional[List[ParameterInformation]]</code> <p>The parameters of this signature.</p> required <code>activeParameter</code> <code>Optional[int]</code> <p>The index of the active parameter.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class SignatureInformation(BaseModel):\n    \"\"\"Represents the signature of something callable.\n\n    Args:\n        label (str): The label of this signature.\n        documentation (Optional[Union[MarkupContent, str]]): The human-readable doc-comment of this signature.\n        parameters (Optional[List[ParameterInformation]]): The parameters of this signature.\n        activeParameter (Optional[int]): The index of the active parameter.\n    \"\"\"\n\n    label: str\n    documentation: t.Optional[t.Union[MarkupContent, str]]\n    parameters: t.Optional[t.List[ParameterInformation]]\n    activeParameter: t.Optional[int]\n</code></pre>"},{"location":"api/structs/#tarts.structs.SymbolInformation","title":"<code>SymbolInformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents information about programming constructs like variables, classes, interfaces etc.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of this symbol.</p> required <code>kind</code> <code>SymbolKind</code> <p>The kind of this symbol.</p> required <code>tags</code> <code>Optional[List[SymbolTag]]</code> <p>Tags for this symbol.</p> required <code>deprecated</code> <code>Optional[bool]</code> <p>Indicates if this symbol is deprecated.</p> required <code>location</code> <code>Location</code> <p>The location of this symbol.</p> required <code>containerName</code> <code>Optional[str]</code> <p>The name of the symbol containing this symbol.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class SymbolInformation(BaseModel):\n    \"\"\"Represents information about programming constructs like variables, classes, interfaces etc.\n\n    Args:\n        name (str): The name of this symbol.\n        kind (SymbolKind): The kind of this symbol.\n        tags (Optional[List[SymbolTag]]): Tags for this symbol.\n        deprecated (Optional[bool]): Indicates if this symbol is deprecated.\n        location (Location): The location of this symbol.\n        containerName (Optional[str]): The name of the symbol containing this symbol.\n    \"\"\"\n\n    name: str\n    kind: SymbolKind\n    tags: t.Optional[t.List[SymbolTag]]\n    deprecated: t.Optional[bool]\n    location: Location\n    containerName: t.Optional[str]\n</code></pre>"},{"location":"api/structs/#tarts.structs.SymbolKind","title":"<code>SymbolKind</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of symbol kinds.</p> <p>Attributes:</p> Name Type Description <code>FILE</code> <code>int</code> <p>A file symbol.</p> <code>MODULE</code> <code>int</code> <p>A module symbol.</p> <code>NAMESPACE</code> <code>int</code> <p>A namespace symbol.</p> <code>PACKAGE</code> <code>int</code> <p>A package symbol.</p> <code>CLASS</code> <code>int</code> <p>A class symbol.</p> <code>METHOD</code> <code>int</code> <p>A method symbol.</p> <code>PROPERTY</code> <code>int</code> <p>A property symbol.</p> <code>FIELD</code> <code>int</code> <p>A field symbol.</p> <code>CONSTRUCTOR</code> <code>int</code> <p>A constructor symbol.</p> <code>ENUM</code> <code>int</code> <p>An enum symbol.</p> <code>INTERFACE</code> <code>int</code> <p>An interface symbol.</p> <code>FUNCTION</code> <code>int</code> <p>A function symbol.</p> <code>VARIABLE</code> <code>int</code> <p>A variable symbol.</p> <code>CONSTANT</code> <code>int</code> <p>A constant symbol.</p> <code>STRING</code> <code>int</code> <p>A string symbol.</p> <code>NUMBER</code> <code>int</code> <p>A number symbol.</p> <code>BOOLEAN</code> <code>int</code> <p>A boolean symbol.</p> <code>ARRAY</code> <code>int</code> <p>An array symbol.</p> <code>OBJECT</code> <code>int</code> <p>An object symbol.</p> <code>KEY</code> <code>int</code> <p>A key symbol.</p> <code>NULL</code> <code>int</code> <p>A null symbol.</p> <code>ENUMMEMBER</code> <code>int</code> <p>An enum member symbol.</p> <code>STRUCT</code> <code>int</code> <p>A struct symbol.</p> <code>EVENT</code> <code>int</code> <p>An event symbol.</p> <code>OPERATOR</code> <code>int</code> <p>An operator symbol.</p> <code>TYPEPARAMETER</code> <code>int</code> <p>A type parameter symbol.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class SymbolKind(enum.IntEnum):\n    \"\"\"Enumeration of symbol kinds.\n\n    Attributes:\n        FILE (int): A file symbol.\n        MODULE (int): A module symbol.\n        NAMESPACE (int): A namespace symbol.\n        PACKAGE (int): A package symbol.\n        CLASS (int): A class symbol.\n        METHOD (int): A method symbol.\n        PROPERTY (int): A property symbol.\n        FIELD (int): A field symbol.\n        CONSTRUCTOR (int): A constructor symbol.\n        ENUM (int): An enum symbol.\n        INTERFACE (int): An interface symbol.\n        FUNCTION (int): A function symbol.\n        VARIABLE (int): A variable symbol.\n        CONSTANT (int): A constant symbol.\n        STRING (int): A string symbol.\n        NUMBER (int): A number symbol.\n        BOOLEAN (int): A boolean symbol.\n        ARRAY (int): An array symbol.\n        OBJECT (int): An object symbol.\n        KEY (int): A key symbol.\n        NULL (int): A null symbol.\n        ENUMMEMBER (int): An enum member symbol.\n        STRUCT (int): A struct symbol.\n        EVENT (int): An event symbol.\n        OPERATOR (int): An operator symbol.\n        TYPEPARAMETER (int): A type parameter symbol.\n    \"\"\"\n\n    FILE = 1\n    MODULE = 2\n    NAMESPACE = 3\n    PACKAGE = 4\n    CLASS = 5\n    METHOD = 6\n    PROPERTY = 7\n    FIELD = 8\n    CONSTRUCTOR = 9\n    ENUM = 10\n    INTERFACE = 11\n    FUNCTION = 12\n    VARIABLE = 13\n    CONSTANT = 14\n    STRING = 15\n    NUMBER = 16\n    BOOLEAN = 17\n    ARRAY = 18\n    OBJECT = 19\n    KEY = 20\n    NULL = 21\n    ENUMMEMBER = 22\n    STRUCT = 23\n    EVENT = 24\n    OPERATOR = 25\n    TYPEPARAMETER = 26\n</code></pre>"},{"location":"api/structs/#tarts.structs.SymbolTag","title":"<code>SymbolTag</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of symbol tags.</p> <p>Attributes:</p> Name Type Description <code>DEPRECATED</code> <code>int</code> <p>Indicates that a symbol is deprecated.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class SymbolTag(enum.IntEnum):\n    \"\"\"Enumeration of symbol tags.\n\n    Attributes:\n        DEPRECATED (int): Indicates that a symbol is deprecated.\n    \"\"\"\n\n    DEPRECATED = 1\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentContentChangeEvent","title":"<code>TextDocumentContentChangeEvent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a content change event in a text document.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The new text of the document.</p> required <code>range</code> <code>Optional[Range]</code> <p>The range of the document that changed.</p> required <code>rangeLength</code> <code>Optional[int]</code> <p>The length of the range that changed (deprecated, use .range).</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class TextDocumentContentChangeEvent(BaseModel):\n    \"\"\"Represents a content change event in a text document.\n\n    Args:\n        text (str): The new text of the document.\n        range (Optional[Range]): The range of the document that changed.\n        rangeLength (Optional[int]): The length of the range that changed (deprecated, use .range).\n    \"\"\"\n\n    text: str\n    range: t.Optional[Range]\n    rangeLength: t.Optional[int]  # deprecated, use .range\n\n    def dict(self, **kwargs: t.Any) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Return a dictionary representation of the event.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the event.\n        \"\"\"\n        d = super().dict(**kwargs)\n\n        # vscode-css server requires un-filled values to be absent\n        # TODO: add vscode-css to tests\n        if self.rangeLength is None:\n            del d[\"rangeLength\"]\n        if self.range is None:\n            del d[\"range\"]\n        return d\n\n    @classmethod\n    def range_change(\n        cls,\n        change_start: Position,\n        change_end: Position,\n        change_text: str,\n        old_text: str,\n    ) -&gt; \"TextDocumentContentChangeEvent\":\n        \"\"\"\n        Create a TextDocumentContentChangeEvent reflecting the given changes.\n\n        Args:\n            change_start (Position): The start position of the change.\n            change_end (Position): The end position of the change.\n            change_text (str): The new text for the changed range.\n            old_text (str): The old text of the document.\n\n        Returns:\n            TextDocumentContentChangeEvent: A new instance representing the change.\n\n        Note:\n            If you're creating a list of TextDocumentContentChangeEvent based on many changes,\n            `old_text` must reflect the state of the text after all previous change events happened.\n        \"\"\"\n        change_range = Range(start=change_start, end=change_end)\n        return cls(\n            range=change_range,\n            rangeLength=change_range.calculate_length(old_text),\n            text=change_text,\n        )\n\n    @classmethod\n    def whole_document_change(\n        cls, change_text: str\n    ) -&gt; \"TextDocumentContentChangeEvent\":\n        \"\"\"Create a TextDocumentContentChangeEvent for a whole document change.\n\n        Args:\n            change_text (str): The new text of the entire document.\n\n        Returns:\n            TextDocumentContentChangeEvent: A new instance representing the whole document change.\n        \"\"\"\n        return cls(text=change_text)\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentContentChangeEvent.dict","title":"<code>dict(**kwargs)</code>","text":"<p>Return a dictionary representation of the event.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the event.</p> Source code in <code>tarts\\structs.py</code> <pre><code>def dict(self, **kwargs: t.Any) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Return a dictionary representation of the event.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the event.\n    \"\"\"\n    d = super().dict(**kwargs)\n\n    # vscode-css server requires un-filled values to be absent\n    # TODO: add vscode-css to tests\n    if self.rangeLength is None:\n        del d[\"rangeLength\"]\n    if self.range is None:\n        del d[\"range\"]\n    return d\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentContentChangeEvent.range_change","title":"<code>range_change(change_start, change_end, change_text, old_text)</code>  <code>classmethod</code>","text":"<p>Create a TextDocumentContentChangeEvent reflecting the given changes.</p> <p>Parameters:</p> Name Type Description Default <code>change_start</code> <code>Position</code> <p>The start position of the change.</p> required <code>change_end</code> <code>Position</code> <p>The end position of the change.</p> required <code>change_text</code> <code>str</code> <p>The new text for the changed range.</p> required <code>old_text</code> <code>str</code> <p>The old text of the document.</p> required <p>Returns:</p> Name Type Description <code>TextDocumentContentChangeEvent</code> <code>TextDocumentContentChangeEvent</code> <p>A new instance representing the change.</p> Note <p>If you're creating a list of TextDocumentContentChangeEvent based on many changes, <code>old_text</code> must reflect the state of the text after all previous change events happened.</p> Source code in <code>tarts\\structs.py</code> <pre><code>@classmethod\ndef range_change(\n    cls,\n    change_start: Position,\n    change_end: Position,\n    change_text: str,\n    old_text: str,\n) -&gt; \"TextDocumentContentChangeEvent\":\n    \"\"\"\n    Create a TextDocumentContentChangeEvent reflecting the given changes.\n\n    Args:\n        change_start (Position): The start position of the change.\n        change_end (Position): The end position of the change.\n        change_text (str): The new text for the changed range.\n        old_text (str): The old text of the document.\n\n    Returns:\n        TextDocumentContentChangeEvent: A new instance representing the change.\n\n    Note:\n        If you're creating a list of TextDocumentContentChangeEvent based on many changes,\n        `old_text` must reflect the state of the text after all previous change events happened.\n    \"\"\"\n    change_range = Range(start=change_start, end=change_end)\n    return cls(\n        range=change_range,\n        rangeLength=change_range.calculate_length(old_text),\n        text=change_text,\n    )\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentContentChangeEvent.whole_document_change","title":"<code>whole_document_change(change_text)</code>  <code>classmethod</code>","text":"<p>Create a TextDocumentContentChangeEvent for a whole document change.</p> <p>Parameters:</p> Name Type Description Default <code>change_text</code> <code>str</code> <p>The new text of the entire document.</p> required <p>Returns:</p> Name Type Description <code>TextDocumentContentChangeEvent</code> <code>TextDocumentContentChangeEvent</code> <p>A new instance representing the whole document change.</p> Source code in <code>tarts\\structs.py</code> <pre><code>@classmethod\ndef whole_document_change(\n    cls, change_text: str\n) -&gt; \"TextDocumentContentChangeEvent\":\n    \"\"\"Create a TextDocumentContentChangeEvent for a whole document change.\n\n    Args:\n        change_text (str): The new text of the entire document.\n\n    Returns:\n        TextDocumentContentChangeEvent: A new instance representing the whole document change.\n    \"\"\"\n    return cls(text=change_text)\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentEdit","title":"<code>TextDocumentEdit</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes textual changes on a single text document.</p> <p>Parameters:</p> Name Type Description Default <code>textDocument</code> <code>OptionalVersionedTextDocumentIdentifier</code> <p>The text document to change.</p> required <code>edits</code> <code>List[TextEdit]</code> <p>The edits to be applied.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class TextDocumentEdit(BaseModel):\n    \"\"\"Describes textual changes on a single text document.\n\n    Args:\n        textDocument (OptionalVersionedTextDocumentIdentifier): The text document to change.\n        edits (List[TextEdit]): The edits to be applied.\n    \"\"\"\n\n    textDocument: OptionalVersionedTextDocumentIdentifier\n    edits: t.List[TextEdit]\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentIdentifier","title":"<code>TextDocumentIdentifier</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Text document identifier for LSP requests.</p> <p>Parameters:</p> Name Type Description Default <code>uri(str)</code> <p>The URI of the document</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class TextDocumentIdentifier(BaseModel):\n    \"\"\"Text document identifier for LSP requests.\n\n    Args:\n        uri(str): The URI of the document\n    \"\"\"\n\n    uri: str\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentItem","title":"<code>TextDocumentItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Text document item for LSP notifications.</p> <p>Parameters:</p> Name Type Description Default <code>uri(str)</code> <p>The URI of the document.</p> required <code>languageId(str)</code> <p>The language ID of the document.</p> required <code>version(int)</code> <p>The version of the document.</p> required <code>text(str)</code> <p>The text of the document.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class TextDocumentItem(BaseModel):\n    \"\"\"Text document item for LSP notifications.\n\n    Args:\n        uri(str): The URI of the document.\n        languageId(str): The language ID of the document.\n        version(int): The version of the document.\n        text(str): The text of the document.\n    \"\"\"\n\n    uri: str\n    languageId: str\n    version: int\n    text: str\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentPosition","title":"<code>TextDocumentPosition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a position in a text document.</p> <p>Parameters:</p> Name Type Description Default <code>textDocument</code> <code>TextDocumentIdentifier</code> <p>The text document.</p> required <code>position</code> <code>Position</code> <p>The position inside the text document.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class TextDocumentPosition(BaseModel):\n    \"\"\"Represents a position in a text document.\n\n    Args:\n        textDocument (TextDocumentIdentifier): The text document.\n        position (Position): The position inside the text document.\n    \"\"\"\n\n    textDocument: TextDocumentIdentifier\n    position: Position\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentSaveReason","title":"<code>TextDocumentSaveReason</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Represents reasons why a text document is saved.</p> <p>Attributes:</p> Name Type Description <code>MANUAL</code> <p>Manually triggered, e.g. by the user pressing save, by starting debugging, or by an API call.</p> <code>AFTER_DELAY</code> <p>Automatic after a delay.</p> <code>FOCUS_OUT</code> <p>When the editor lost focus.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class TextDocumentSaveReason(enum.IntEnum):\n    \"\"\"Represents reasons why a text document is saved.\n\n    Attributes:\n        MANUAL: Manually triggered, e.g. by the user pressing save, by starting debugging, or by an API call.\n        AFTER_DELAY: Automatic after a delay.\n        FOCUS_OUT: When the editor lost focus.\n    \"\"\"\n\n    MANUAL = 1\n    AFTER_DELAY = 2\n    FOCUS_OUT = 3\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextDocumentSyncKind","title":"<code>TextDocumentSyncKind</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of text document synchronization kinds.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>int</code> <p>Documents should not be synced at all.</p> <code>FULL</code> <code>int</code> <p>Documents are synced by always sending the full content of the document.</p> <code>INCREMENTAL</code> <code>int</code> <p>Documents are synced by sending incremental updates to the document.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class TextDocumentSyncKind(enum.IntEnum):\n    \"\"\"Enumeration of text document synchronization kinds.\n\n    Attributes:\n        NONE (int): Documents should not be synced at all.\n        FULL (int): Documents are synced by always sending the full content of the document.\n        INCREMENTAL (int): Documents are synced by sending incremental updates to the document.\n    \"\"\"\n\n    NONE = 0\n    FULL = 1\n    INCREMENTAL = 2\n</code></pre>"},{"location":"api/structs/#tarts.structs.TextEdit","title":"<code>TextEdit</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A text edit applicable to a text document.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>Range</code> <p>The range of the text document to be manipulated.</p> required <code>newText</code> <code>str</code> <p>The string to be inserted. For delete operations use an empty string.</p> required <code>annotationId</code> <code>Optional[str]</code> <p>An optional identifier of the edit.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class TextEdit(BaseModel):\n    \"\"\"A text edit applicable to a text document.\n\n    Args:\n        range (Range): The range of the text document to be manipulated.\n        newText (str): The string to be inserted. For delete operations use an empty string.\n        annotationId (Optional[str]): An optional identifier of the edit.\n    \"\"\"\n\n    range: Range\n    newText: str\n    annotationId: t.Optional[str]\n</code></pre>"},{"location":"api/structs/#tarts.structs.VersionedTextDocumentIdentifier","title":"<code>VersionedTextDocumentIdentifier</code>","text":"<p>               Bases: <code>TextDocumentIdentifier</code></p> <p>Text document identifier with a version for LSP notifications.</p> <p>Parameters:</p> Name Type Description Default <code>uri(str)</code> <p>The URI of the document</p> required <code>version(int)</code> <p>The version of the document</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class VersionedTextDocumentIdentifier(TextDocumentIdentifier):\n    \"\"\"Text document identifier with a version for LSP notifications.\n\n    Args:\n        uri(str): The URI of the document\n        version(int): The version of the document\n    \"\"\"\n\n    version: t.Optional[int]\n</code></pre>"},{"location":"api/structs/#tarts.structs.WorkDoneProgressBeginValue","title":"<code>WorkDoneProgressBeginValue</code>","text":"<p>               Bases: <code>WorkDoneProgressValue</code></p> <p>Represents the beginning of a work done progress.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['begin']</code> <p>The kind of progress (always \"begin\" for this class).</p> required <code>title</code> <code>str</code> <p>The title of the progress operation.</p> required <code>cancellable</code> <code>Optional[bool]</code> <p>Whether the operation is cancellable.</p> required <code>message</code> <code>Optional[str]</code> <p>An optional message providing additional details.</p> required <code>percentage</code> <code>Optional[int]</code> <p>An optional initial percentage of the progress.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class WorkDoneProgressBeginValue(WorkDoneProgressValue):\n    \"\"\"Represents the beginning of a work done progress.\n\n    Args:\n        kind (Literal[\"begin\"]): The kind of progress (always \"begin\" for this class).\n        title (str): The title of the progress operation.\n        cancellable (Optional[bool]): Whether the operation is cancellable.\n        message (Optional[str]): An optional message providing additional details.\n        percentage (Optional[int]): An optional initial percentage of the progress.\n    \"\"\"\n\n    kind: Literal[\"begin\"]\n    title: str\n    cancellable: t.Optional[bool]\n    message: t.Optional[str]\n    percentage: t.Optional[int]\n</code></pre>"},{"location":"api/structs/#tarts.structs.WorkDoneProgressEndValue","title":"<code>WorkDoneProgressEndValue</code>","text":"<p>               Bases: <code>WorkDoneProgressValue</code></p> <p>Represents the end of a work done progress.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['end']</code> <p>The kind of progress (always \"end\" for this class).</p> required <code>message</code> <code>Optional[str]</code> <p>An optional message providing final details or results.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class WorkDoneProgressEndValue(WorkDoneProgressValue):\n    \"\"\"Represents the end of a work done progress.\n\n    Args:\n        kind (Literal[\"end\"]): The kind of progress (always \"end\" for this class).\n        message (Optional[str]): An optional message providing final details or results.\n    \"\"\"\n\n    kind: Literal[\"end\"]\n    message: t.Optional[str]\n</code></pre>"},{"location":"api/structs/#tarts.structs.WorkDoneProgressReportValue","title":"<code>WorkDoneProgressReportValue</code>","text":"<p>               Bases: <code>WorkDoneProgressValue</code></p> <p>Represents a report of ongoing work done progress.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Literal['report']</code> <p>The kind of progress (always \"report\" for this class).</p> required <code>cancellable</code> <code>Optional[bool]</code> <p>Whether the operation is cancellable.</p> required <code>message</code> <code>Optional[str]</code> <p>An optional message providing additional details.</p> required <code>percentage</code> <code>Optional[int]</code> <p>An optional updated percentage of the progress.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class WorkDoneProgressReportValue(WorkDoneProgressValue):\n    \"\"\"Represents a report of ongoing work done progress.\n\n    Args:\n        kind (Literal[\"report\"]): The kind of progress (always \"report\" for this class).\n        cancellable (Optional[bool]): Whether the operation is cancellable.\n        message (Optional[str]): An optional message providing additional details.\n        percentage (Optional[int]): An optional updated percentage of the progress.\n    \"\"\"\n\n    kind: Literal[\"report\"]\n    cancellable: t.Optional[bool]\n    message: t.Optional[str]\n    percentage: t.Optional[int]\n</code></pre>"},{"location":"api/structs/#tarts.structs.WorkDoneProgressValue","title":"<code>WorkDoneProgressValue</code>","text":"<p>               Bases: <code>ProgressValue</code></p> <p>Base class for work done progress values.</p> Source code in <code>tarts\\structs.py</code> <pre><code>class WorkDoneProgressValue(ProgressValue):\n    \"\"\"Base class for work done progress values.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/structs/#tarts.structs.WorkspaceFolder","title":"<code>WorkspaceFolder</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a workspace folder.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The associated URI for this workspace folder.</p> required <code>name</code> <code>str</code> <p>The name of the workspace folder.</p> required Source code in <code>tarts\\structs.py</code> <pre><code>class WorkspaceFolder(BaseModel):\n    \"\"\"Represents a workspace folder.\n\n    Args:\n        uri (str): The associated URI for this workspace folder.\n        name (str): The name of the workspace folder.\n    \"\"\"\n\n    uri: str\n    name: str\n</code></pre>"}]}